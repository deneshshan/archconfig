aws_config_path
exit
e
exit!
Product.last
Product.where(name: 'Zappi Concept Test')
Product.map(&:name)
Product.map(:name)
Product.last
Product.all.map(:name)
Product.all.map(&:name)
Product.all.map(&:code)
product_name
CapybaraApp.new(nil).product_slug(product_name)
product_name = "Zappistore Product Test"
CapybaraApp.new(nil).product_slug(product_name)
code = _
Product.find_by_code(code)
Product.find_by_name(product_name)
exit
Product.find_by_code("zappi_product_test")
[D]]
exit
Product
Product.first_with_slug_or_id("28")
Product.first_with_slug_or_id("zappi-product-test")
Product.live.from_collection(current_branding.code).first_with_slug_or_id("zappi-product-test")
exit!
Product.live.from_collection(current_branding.code).first_with_slug_or_id(params[:slug_or_id])
current_branding.code
Product.live.from_collection(current_branding.code)
exit!
exit
exit!
exit
exit!
execute_script %Q[ var e = $.Event('keydown', { keyCode: 13 }); $('input[ng-model="newQuestionText"]').trigger(e); ]
execute_script %Q[ var e = $.Event('keydown', { keyCode: 13 }); $('input[ng-model="newQuestionText"]').val('llol').trigger(e); ]
exit1
exit!
find('#customQuestion0")
find('#customQuestion0').
find('#customQuestion0')
find('#customQuestion0').native.send_keys(:return)
find('#customQuestion0').native.send_keys(:enter)
find('#customQuestion0').native.send_keys(13)
find('#customQuestion0').native.send_keys(:enter)
find('#customQuestion1').native.send_keys(arg1)
find('#customQuestion1').native.send_keys(enter)
find('#customQuestion1').native.send_keys(:enter)
rand(0..5)
rand(0..5).to_a
(0..5).to_a.sample
(1..rand(10)
)
(1..rand(10))
exit!
e
exit
find("customQuestion#{ question_number }").native.send_keys(question)
find("customQuestion#{ question_number }").native.send_keys('aaa')
exit
exit!
question
number
next
e
exit
n
next
exit!
number
find("customQuestion#{ number }").native.send_keys(question)
find("#customQuestion#{ number }").native.send_keys(question)
number
find("#customQuestion0").native.send_keys(question)
find("#customQuestion0").native.send_keys(:enter)
exit
e
exit!
find("#customQuestion#{ number }").native.send_keys(question)
find("#customQuestion#{ number }").native.send_keys(:enter)
exit
e
exit
exit!
exit
find("#customQuestion#{ question_number }newAnswer").native.send_keys('answer ')
find("#customQuestion#{ question_number }newAnswer").native.send_keys(19)
find("#customQuestion#{ question_number }newAnswer").native.send_keys(:enter)
exit
Baden-WÃ¼rttemberg
Bayern
Berlin
Mecklenburg-Vorpommern, Brandenburg, Sachsen-Anhalt
exit
e
exit
e
exit
selector
all(selector)
sel = 'section#country-configuration li'
all(sel)
all(sel)['enabled']
find(sel)['class']
exit
args
page.unselect_all_toggles_except "Region", *args.split(/\s*\|\s*/)
exit
exit!
find(selector)
find(selector)['class']
find(selector)['class'].include?('enabled')
exit
find(selector)['class'].include?('enabled')
exit
find(selector)['class'].include?('enabled')
exit
e
exit
all(selector)
all(selector)['class']
find(selector)['class']
exit!
e
exit
exit!
find(selector)
find('#scontinueWithChoices')
find('#continueWithChoices')
find('#continueWithChoices.enabled')
find('#continueWithChoices .enabled')
exit!
enabled_selector
exit
enabled_selector
selector
exit!
enabled_selector
exit
enabled_selector
exit
enabled_selector
all(enabled_selector)
exit
enabled_selector
exit
total_answers
total_answers.to_i
total_answers = total_answers.to_i
exit
enabled_selector
exit
enabled_selector
exit
exit!
exit
e
exit
exit!
|?".e
e
exit
exit!
exit
exit!
exit
e
exit
e
exit
e
exit
e
exit
e
exit
enabled_selector
find(enabled_selector)
find(section#country-configuration li)
  find('section#country-configuration li')
find('section#country-configuration li')
all('section#country-configuration li')
all('section#country-configuration')
all('#country-configuration')
exit
e
exit!
exit
e
exit
page.sidebard.class
page.sidebar.class
exit!
page.sidebar.method(:wait_until_continue_button_visible)
page.sidebar.method(:wait_until_continue_button_visible).source_location
page.sidebar.wait_until_continue_button_visible
exit!
exit
SystemUser.find_by_email('denesh@zappistore.com')
SystemUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
den = _
den.add_role :super_admin
den.save!
exit
e
exit
e
exit
e
exit
e
exit
all(enabled_selector)
exit
all(enabled_selector)
enabled_selector
exit
exit!
exit
e
exit
e
exit
exit1
exit!
exit
e
exit!
e
exit
exit!
exit
e
exit!
exit
exit!
exit
exit!
exit
product_name
app = CapybaraApp.new(nil)
app.product_slug(product_name)
exit!
CapybaraApp.new(nil).product_slug(product_name)
exit
exit!
exit
e
exit!
exit
exit!
ll(".blockUI")
all(".blockUI")
res = _
res.any?
exit!
all(".blockUI")
exit
exit!
exit
exit!
find(selector + '.enabled')
find(selector + '.enabled').click
next
find(selector + '.enabled')
find(selector + '.enabled')['class']
find(selector + '.enabled')('enabled')
find(selector + '.enabled')['enabled']
find(selector + '.enabled')[:disabled]
find(selector + '.enabled').click
page.save_screenshot('tmp/bjate_continue2.png')
find(selector + '.enabled').html
page.click_link('Continue with these choices')
node = find(selector + '.enabled')
node.native
node.native.ext
node.native.text
exit
page.click(selector)
click(selector)
page.click_button
page.click_button(selector)
page.save_screenshot('tmp/bjate_continue3.png')
page.execute_script "window.scrollBy(0,-10000)"
page.save_screenshot('tmp/bjate_continue4.png')
page.execute_script "window.scrollBy(0,10000)"
page.save_screenshot('tmp/bjate_continue5.png')
page.click_button(selector)
find(selector + '.enabled').click
page.save_screenshot('tmp/bjate_continue6.png')
find(selector + '.enabled')
find(selector + '.enabled')['class']
exit!
e
exit!
page.execute_script("$('#continueWithChoices').trigger('click')")
page.save_screenshot('tmp/bjate_continue7.png')
exit
page.execute_script("$('#continueWithChoices').trigger('click')")
page.save_screenshot('tmp/bjate_continue8.png')
exit!
exit
e
exit
e
exit
page.save_screenshot('tmp/bjate_continue9.png')
exit!
e
exit
e
exit
page.save_screenshot('tmp/order_rev.png')
execute_script %Q[ window.scrollBy(0,-10000) ]
page.save_screenshot('tmp/order_rev.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev.png')
page.all("input[type=file]", visible: false).first.set( File.absolute_path("features/data/#{path}") )
page.save_screenshot('tmp/order_rev.png')
page.all("input[type=file]", visible: false).first.set( File.absolute_path("features/data/test.mp4") )
page.save_screenshot('tmp/order_rev.png')
File.absolute_path("features/data/test.mp4")
page.all("input[type=file]", visible: false).first.set( File.absolute_path("features/data/test.mp4") )
page.save_screenshot('tmp/order_rev.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev2.png')
execute_script %Q[ $('input[ng-model="surveyComponent.title"]').val('123456').trigger("change") ]
page.save_screenshot('tmp/order_rev3.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev4.png')
execute_script %Q[ $('button:contains("Save")').click() ]
page.save_screenshot('tmp/order_rev5.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev5.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev5.png')
page.save_screenshot('tmp/order_rev6.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev6.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev6.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev6.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev6.png')
execute_script %Q[ window.scrollBy(0,5000) ]
page.save_screenshot('tmp/order_rev6.png')
page.execute_script("$('#continueWithChoices').trigger('click')")
page.save_screenshot('tmp/order_rev.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev2.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/order_rev3.png')
page
page.text
exit
And I enter title "Smoking is cool"
execute_script %Q[ $('input[ng-model="surveyComponent.title"]').val('smoking is cool)).trigger("change")]
execute_script %Q[ $('input[ng-model="surveyComponent.title"]').val('smoking is cool).trigger("change")]
exit!
execute_script %Q[ $('button:contains("Save")').click() ]
exit!
exit
execute_script %Q[ $('input[ng-model="surveyComponent.title"]').val(#{arg1.to_json}).trigger("change") ]
exit
exit!
exit
next
exit
execute_script %Q[ $('input[ng-model="surveyComponent.title"]').val(#{arg1.to_json}).trigger("change") ]
execute_script %Q[ $('input[ng-model="surveyComponent.title"]').val('hi there').trigger("change") ]
exit!
exit
find(selector)
exit
exit!
exit
exit!
exit
page.show_country_dropdown
page.choose_country_button(country_name)
exit!
execute_script %Q[ $('#country-configuration a:contains(#{country_name.to_json})') ]
exit!
exit
exi!
exit!
exit
find("#customQuestion#{ question_number }newAnswer")
find("#customQuestion#{ question_number }newAnswer").native.send_keys('lol')
exit
n
next
e
exit!
element.native.send_keys('answer ')
element.native.send_keys(answer_number)
element.native.send_keys(:enter)
page.save_screenshot('tmp/cq.png')
element.native.send_keys(:enter)
element.native.send_keys('hi')
element.send_keys('hi')
element.send_keys(:enter)
element.native.trigger(:enter)
find("#customQuestion#{ question_number }newAnswer")
node = _
node.native
node.native.trigger(:enter)
node.set('hi'0
node.set('hi')
node.native.send_keys(:enter)
node.trigger('click')
page.save_screenshot('tmp/cq.png')
node.native.send_keys(:enter)
node.set('there ' + answer_number)
node.set("there #{ answer_number }")
page.save_screenshot('tmp/cq2.png')
node.native.send_keys(:enter)
page.save_screenshot('tmp/cq3.png')
exit!
page.driver.browser.key_down(:enter).key_up(:enter).perform
element.native.send_keys(:enter)
exit
product_name
CapybaraApp.new(nil).product_slug(product_name)
next
next"/checkout/#{slug}/product_target"
"/checkout/#{slug}/product_target"
next
exception
exit!
exit
all(selector)
find(selector)
exit
all(selector)
find(selector)
exit
all(selector)
all(selector).any?
exitQ
exit!
all("customQuestion2newAnswer")
all("#customQuestion2newAnswer")
exit
$!
selector
all(selector)
exit
all(selector)
selector
exit!
all('#continueWithChoices'.enabled')
all('#continueWithChoices.enabled')
  '
'
all('#continueWithChoices.enabled')
exit
exit!
selector
page
page.save_screenshot('tmp/lol.png')
execute_script %Q[ window.scrollBy(0,10000) ]
page.save_screenshot('tmp/lol2.png')
execute_script %Q[ window.scrollBy(0,2000) ]
page.save_screenshot('tmp/lol2.png')
all(selector)
all('#customQuestion2')
all('#customQuestion2newAnswer')
exit!
Survey
Survey.all
SurveyRepository.all
SurveyRepository.all_not_sent
sr = SurveyRepository.new.last
sr = SurveyRepository.new.
sr = SurveyRepository.new
sr = Repositories::SurveyRepository.new
sr.last
exit
sr = Repositories::SurveyRepository.new
sr.last
AdminUser
AdminUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
u = _
Role.all
AdminRole.all
u.add_role :super_admin
u.save!
sr.last
sr.find(4553)
exit
configuration_xml
configuration_xml.__send__(:survey_components)
orders_survey
next
order_surveys
survey
exit
survey.class
self.method(:survey)
survey.order.surveys
survey.order.surveys.first.class
survey.order
survey.external_order_
survey.external_order_id
Customer.last
den
den = Customer.last
den.customer_open_credit
den.customer_open_credit.delete
den.customer_open_credit
den.customer_open_credit.destroy!
CustomerOpenCredit.delete(2268)
den.customer_open_credit
exit
den = Customer.last
den.customer_open_credit
den.delete!
den
den.destroy!
exit
Customer.last
exit
Customer.last
den = _
de.confirmed_at = Time.now
den.confirmed_at = Time.now
den.save!
den.customer_open_credit
open_credit
next
errors
next
nex
next
exit
result
result.errors
result.errors.join(", ")
exit
errors.class
exit!
result.errors
result.class
result.errors.class
result.errors.first.class
exit
OpenCredit
CustomerOpenCredit
CustomerOpenCredit.create()
CustomerOpenCredit.create!()
CustomerOpenCredit.create!(credit_remaining: 0, credit_limit: 0)
Currency.last
Currency.first
Currency.find_by(code: "USD")
Currenct.all
Currency.all
Currency.firs
Currency.first
Currency.last
Currency.all
exit
self
self.customer_open_credit
exit!
Customer.first
Customer.laste
Customer.last
last_cust = _
last_cust.destroy!
exit
Customer.last
den = _
den.currency_code
den
den.currency
exit
gbp
exit
gbp
exit
charge
customer_open_credit
customer_open_credit.charges
customer_open_credit.method(:charges).source_location
zeus test --format documentation spec/lib/checkout_system/payment_strategies/open_credit_spec.rb
exit
charge
customer_open_credit.charges
customer
customer.customer_order_credit
customer.order_credit
customer.customer_open_credit
exit!
charge
exit
order
order.customer
zeus test --format documentation spec/controllers/api/v1/orders_controller_spec.rb:23
exit
exit!
customer
customer.customer_open_credit_
exit!
exit
exit!
self.customer_open_credit
exit
exit!
order.customer
exit!
order.customer
order.customer.mailing
order.customer.mailing.mail
exit
order.customer
exit
order.customer
order
exit
order.customer
exit!
order.class
exitk
exit!
Currency.find_by(code: "USD")zeus test --format documentation spec/controllers/api/v1/orders_controller_spec.rb
exit
exit@
exit!
45
exit!
insee_code
exit
question
question.answer_options.count
question.answer_options.each do { |option| puts option.inspect }
question.answer_options.each { |option| puts option.inspect }
question.answer_options.each { |option| puts "a"; }
question.answer_options.each { |option| puts "a"; return nil }
AdminUser
SystemUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', pasword_confirmation: 'c0mpla!ning')
SystemUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
den = _
den.add_role :super_admin
den.save!
Products.all
Product.all
Product.map(&:slug)
Product.all.map(&:slug)
Product.find_by_slug('brainjuicer-facetrace')
question.class
question.answer_options.first.class
exit
exit
question.answer_options.first.class
exit
user = AdminUser.create(email: 'blah@blah.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
user = AdminUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
den = _
den.add_role :super_admin
den.save!
exit
Benchmark.bm { |x| x.report { filter.filter(self, answer_options) } }
filter.class
next
step
answer_options
answer_options.class
answer_options.select { |answer_option| answer_option.fixed? || available_publications.include?(answer_option.content.to_s) }
answer_options.select { |answer_option| answer_option.fixed?  }
answer_options.select { |answer_option| answer_option.content.to_s  }
answer_options.first.content
answer_options.first.content.to_s
answer_options.first.content.class
answer_options.first.class
answer_options.first.content.class
step answer_options.first.content.to_S
step answer_options.first.content.to_s
answer_option.content.to_s
next
context
opts
TranslatableContentComposer.new(self, context, opts)
TranslatableContentComposer.new(self, context, opts).compose
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
exit
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
exit
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
exit
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
exit
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
exit
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
exit
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
exit
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
exit
keys
build_key(keys)
build_alias_key(keys, options[:alias_key])
options.fetch(:finder) { TranslationFinder.new(lang_code) }
next
exnt
next
translation.try(:value)
evaluate_translation_fallback(options[:fallback], options[:original_context], options[:options])
translation
exit
substitution_rules.reduce(text) { |text, rule| rule.apply(text) }
exit
substitution_rules
exit
answer_options.first
exit
content
content.to_yaml
h.raw(context[:display].display(content, options))
exit
answer_option.first
answer_options.first
answer_options.first.content
answer_options.first.content.to_s
exit
exi
exit
answer_options.first.content.class
answer_options.first.content.method(:to_s).source_location
answer_options.select { |answer_option| answer_option.fixed? || available_publications.include?(answer_option.content.to_s) }
available_publications
answer_options
answer_options.select { |answer_option| answer_option.fixed? || available_publications.include?(answer_option.content.to_s) }
answer_options.map{ |a| a.content.to_s }
answer_options.first.content.to_s
GC.start
GC.disable
result = RubyProf.profile { answer_options.first.content.to_s }
printer = RubyProf::GraphHtmlPrinter.new(result)
printer.print(File.open("tmp/visible_answer_options_graph.html", "w+"), min_percent: 3 )
anwser_options.object
anwser_options.first.object
answser_options.first.object
answer_options.first.object
answer_options.first.class
answer_options.first.method(:content).source_location
result = RubyProf.profile { Survey.null.freeze }
result = RubyProf.profile { answer_options.first.content.to_s }
result = RubyProf.profile { Survey.null.freeze }
result = RubyProf.profile { DisplayContext.null }
result = RubyProf.profile { answer_options.first.content.to_s }
result = RubyProf.profile { answer_options.map { |a| a.content.to_s} }
printer = RubyProf::GraphHtmlPrinter.new(result)
printer.print(File.open("tmp/visible_answer_options_graph2.html", "w+"), min_percent: 3 )
respondent_params
AppConfig.params_hashing_key
resp_param = { 'age' => survey.target.age_ranges.first.try(:min) || survey.target.min_age, gender' => survey.target.gender_id, 'project_id' => random_hex_string, 'respondent_id' => random_hex_string, 'region' => survey.target.region_ids.first }
resp_param = { 'age' => survey.target.age_ranges.first.try(:min) || survey.target.min_age, 'gender' => survey.target.gender_id, 'project_id' => random_hex_string, 'respondent_id' => random_hex_string, 'region' => survey.target.region_ids.first }
survey.built_in_respondent_data_keys
survey.built_in_respondent_data_keys.map { |key| key.param_name }
survey
survey.class
survey.method(:built_in_respondent_data_keys).source_location
order = Order.last
order.errors
order.errors.last
order.errors.all
order.errors
exit
Order
ProcessResult
ProcessingResult
MillwardbrownConnector::ReferenceData::BrandsClient
MillwardbrownConnector::ReferenceData::BrandsClient.get_list_response('Nike')
MillwardbrownConnector::ReferenceData::BrandsClient.new.get_list_response('Nike')
MillwardbrownConnector::ReferenceData::BrandsClient.get_list_from('link')
MillwardbrownConnector::ReferenceData::BrandsClient.new.get_list_from('link')
exit
MillwardbrownConnector::ReferenceData::BrandsClient.new.get_list_from('link')
exit
MillwardbrownConnector::ReferenceData::BrandsClient.new.get_list_from('link')
exit
MillwardbrownConnector::ReferenceData::BrandsClient.new.get_list_from('link')
exit
exitexit
exit
answer_options
exit
answer_options.first
answer_options.first.content
answer_options.first.content.to_s
exit
Rails.cache
Rails.cache.clear
Rails.cache
Rails.cache.connection
exit
text
exit
answer_option.first.class
answer_options.first.content.class
answer_options
exit
context
context.survey
exit
context
context.to_yaml
PP.pp context
exit
context
exit
options[:original_context]
exit
source
source.class
context
context.class
PP.pp context
caller
caller.reject { |x| !x.include?("data-collector") }
context.class
context.configuration
context.configuration.class
context.configuration[:blueprint]
context.class
context.configuration[:blueprint]
context.configuration[:blueprint].class
context.configuration.blueprint
context.configuration
context.configuration.blueprint_id
TranslationCache
HTTPconnector
HTTPConnector
TranslationCache
exit
TranslationCache
j 26
exit
TranslationCache
exit
TranslationCache
exit
TranslationNullCache
TranslationCache
TranslationCacheBase
TranslationNullCache
exit
Services
Services::TranslationCache
exit
key
options
alias_key
keys
lang_code
exit
caller
caller.reject { |x| x.include?('data-collector') }
caller.reject { |x| !x.include?('data-collector') }
opts
exit
caller.reject { |x| !x.include?('data-collector') }
exit
translation_cache
question_or_generator
question_or_generator.class
caller
caller.reject { |x| !x.include?('data-collector') }
exit
caller.reject { |x| !x.include?('data-collector') }
translation_cache
exit
caller.reject { |x| !x.include?('data-collector') }
up
caller.reject { |x| !x.include?('data-collector') }
up
options
up
opts
up
opts
up
opts
up
opts
translation_cache
up
translation_cache
opts
down
opts
up
opts
exit
options
exit
options
exit
options
caller.reject { |x| !x.include?('data-collector') }
exit
caller.reject { |x| !x.include?('data-collector') }
exit
opts
exit
exit
caller.reject { |x| !x.include?('data-collector') }
context
key
options
options[:translation_cache]
caller.reject { |x| !x.include?('data-collector') }
up
options
up
caller.reject { |x| !x.include?('data-collector') }
up
survey
down
survey
up
down
survey
caller.reject { |x| !x.include?('data-collector') }
exit
caller.reject { |x| !x.include?('data-collector') }
up
caller.reject { |x| !x.include?('data-collector') }
up
cache(options)
options
exit
options
up
options
up
optiosn
options
up
opt
opts
up
options
down
options
options[:survey_id]
exit
options
caller.reject { |x| !x.include?('data-collector') }
up
]up
up
options
up
options
up
options
up
opts
up
opt
opts
up
opts
up
opts
up
opts
up
opts
up
opts
survey_id
blueprint.id
down
opts
cache(options)
cache(options).fetch(lang_code, alias_key)
lang_code
alias_key
key
options
options[:survey_id]
options[:blueprint_id]
exit
SecureRandom.hex
exit
next
context
context.id
exit
lol = nil
lol2 = nil
"#{ lol }:#{ lol2 }"
exit
Rails.configuration.database_configuration[Rails.env]
exit
Resque.redis
exit
dynamic_stage.key
configuration
finder
exit
text
exit
value
text
configuration[key]
key
configuration
exit
value
text
component
key
exit
text
exit
value
text
exit
text
key
alias_key
finder
finder.find(key, alias_key
  (
)
finder.find(key, alias_key)
exit
translation
translation.lang_code
translation.key
exit
Rails.cache
Rails.cache.all
Rails.cache.fetch()
Rails.cache.key_matcher(".*:alias_key")
Rails.cache.send(:key_matcher, ".*:alias_key")
Rails.cache.send(:key_matcher, "alias_key", {})
Rails.cache.find("alias"0
Rails.cache.find("alias")
Rails.cache.fetch("alias")
Rails.cache.fetch(".*alias.*")
Redis
redis = Redis.new(db:2)
redis.get("#{ lang_code }:#{ key }:#{ alias_key }"
)
Rails.cache.fetch("#{ lang_code }:#{ key }:#{ alias_key }")
kjrspec --format documentation spec/services/translation_cache_spec.rb:31
exit
context.try(:survey_response)
!compositions_applied.include?(composition_name)
context.user_agent_device_mobile?
context
exit
context.user_agent_device_mobile?
context.try(:survey_response)
exit
context
exit
context.try(:survey_response)
context.user_agent_device_mobile?
!compositions_applied.include?(composition_name)
exit
keys
exit
keys
exit
Rails.cache.fetch("#{ lang_code }:#{ key }")
exit
translation.class
translation
exit
translation
exit
project.class
exit!
Translation.all
TranslationRepository.all
DatabaseModels::Translations
DatabaseModels::Translations.all
DatabaseModels::Translation.all
DatabaseModels::Translation.first
cache = Services::TranslationCache.new
DatabaseModels::Translation.each do |translation| cache.fetch(translation.lang_code, translation.key) do translation end end
DatabaseModels::Translation.all.each do |translation| cache.fetch(translation.lang_code, translation.key) do translation end end
exit
Rails.cache.clear
exit
Rails.cache.clear
exit
Rails.cache.clear
exit
User.last
exit
User.last
exit
Customer.last
Customer.where(email: 'denesh@zappistore.com')
_.first
denesh = _
denesh
denesh.confirmed_at = Time.now
denesh.save!
exit
ProductConfiguration.last
ProductConfiguration
ProductConfiguration.last
current_product_configuration.class
current_product_configuration.survey_components.first.class
current_product_configuration.survey_components.first
exit
current_product_configuration.survey_components.first
current_product_configuration.survey_components.first.class
SurveyComponents::FavorIt::ImageComponent
SurveyComponentModels::FavorIt::ImageComponent
SurveyComponentModels::FavourIt::ImageComponent
SurveyComponentModels::FavourIt::ImageComponent.last
SurveyComponentModels::FavourIt::ImageComponent.last.images
SurveyComponentModels::FavourIt::ImageComponent.last.images.first
oim = _
oim.order_image_media
oim.order_image_media_relations
oim.medium_entity
current_product_configuration.survey_components
OrderDat
OrderData
OrderData.last
CheckoutSystemModels::Medium.last
medium = _
medium.product_setup_base
medium.product_setup
medium.order_data
medium.order
exit
SurveyComponentModels::FavourIt::ImageComponent.last
SurveyComponentModels::FavourIt::ImageComponent.last.key
data_storage
next
current_product_configuration.survey_components.first
fiic = _
fiic.survey_component_entity
fiic.order_survey_component
fiic.class
fiic.images
fiic.images.first
image_comp = _
image_comp.images
Order.last.order_data
Order.last.order_data.fetch('media', [])
exit
components_to_destroy = current_survey_components.select do |component| section_id.present? && component.section_id == section_id end
components_to_destroy.count
current_survey_components
exit
Order.last
SurveyComponentModels::FavourIt::ImageComponent
SurveyComponentModels::FavourIt::ImageComponent.last
SurveyComponentModels::FavourIt::ImageComponent.find(order: 'id desc', limit: 5)
SurveyComponentModels::FavourIt::ImageComponent.find(:all, order: 'id desc', limit: 5)
SurveyComponentModels::FavourIt::ImageComponent.find(:all, :order => 'id desc', limit: 5)
SurveyComponentModels::FavourIt::ImageComponent.find(:all, :order => 'id desc', :limit => 5)
SurveyComponentModels::FavourIt::ImageComponent.last(5)
SurveyComponentModels::FavourIt::ImageComponent.all
@checkout_session.class
@checkout_session
exit
CheckoutSystemModels
CheckoutSystemModels::CheckoutSession.last
exit!
SurveyComponentModels::FavourIt::ImageComponent.all
exit
Order.last
SurveyComponentModels::FavourIt::ImageComponent.last.key
SurveyComponentModels::FavourIt::ImageComponent.all
components_to_destroy = current_survey_components.select do |component| section_id.present? && component.section_id == section_id  end
exit!
exit
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.all
Order.last
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.all
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.last
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.last(3)
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.all
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.count
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.last
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.count
CheckoutSystemModels::SurveyComponents::FavourIt::ImageComponent.last
image = _
image.destroy
exit
exit!
Survey::Null.instance
exit
survey
allow(survey).to receive(:configuration) { configuration }
exit
allow(survey).to receive(:configuration) { configuration }
allow_any_instance_of(SurveyResponseLanguage).to receive(:execute) { 'GB_en' }
exit
expect(subject.additional_context[:context_key]).to eq('context value')
next
exit
num = 1
num.freeze
exit
subject.media
exit1
exit!
element.class
element.method(:width).source_location
element.context
element.context[:component_size]
element.send(:default_component_size)
element.component[:component_size]
element.context[:display]
element.context[:display].survey.survey_component
element.context[:display].survey.survey_component[:component_size]
PP.pp element.context[:display].survey.survey_component
element.context
PP.pp element.context
caller.reject { |x| !x.include?('data-collector') }
element.method(:context).source_location
element.context.class
exit
methods
exit
methods
caller
caller.reject { |x| !x.include?('data-collector') }
exit
next
exit
next
exit
CheckoutSystemModels
CheckoutSystemModels::DestroyableMedia
exit
CheckoutSystemModels::SurveyComponents::DestroyableMedia
exit
CheckoutSystemModels::SurveyComponents::LinkNowDigital::StandardDesktopFlashComponent
_.new
comp = _
comp.try(:media_attributes)
exit
subject.media_attribute_names
exit!
subject.media_attribute_names.each do |attribute|
  medium = subject.send(attribute)
  unless medium.is_a?(Array)
    expect(medium).to_not eq nil
  else
    expect(medium).to_not be empty
    medium.each { |med| expect(med).to_not be nil }
  end
end
subject.media_attribute_names.each do |attribute|
  medium = subject.send(attribute)
  medium
  medium.count
end
exit!
subject.media_attribute_names.each do |attribute| 
  medium = subject.send(attribute)
  unless medium.is_a?(Array)
    expect(medium).to_not eq nil
  else
    expect(medium).to_not be empty
    medium.each { |med| expect(med).to_not be nil }
  end
end
subject.media_attribute_names.map { |attribute| 
medium
subject.media_attribute_names.map { |attribute| attribute }
exit
medium
exit
subject.media_attribute_names
exit
subject.media_attribute_names
exit
subject.media_attribute_names
zeus test --format documentation spec/lib/mongo_models/checkout_system_models/survey_components/att_digital_creative_test/instagram_video_component_spec.rb
exit
subject.media_attribute_names
exit
media
exit
exit!
medium
attribue
attribute
subject.send(attribute)
media_names
subject.concept_medium
zeus test --format documentation spec/lib/mongo_models/checkout_system_models/survey_components/regional_press/paper_publication_component_spec.rb
zeus test --format documentation spec/lib/mongo_models/checkout_system_models/survey_components/link_now_digital/standard_mobile_video_component_spec.rb
exit
subject.send(:medium_model_class)
subject.send(:medium_model_class).all
subject.send(:medium_model_class).find({})
subject.send(:medium_model_class).where(owner_section_id: subject.section_id)
subject.section_id
exit
subject.section_id
exit
CheckoutSystemModels::Medium.where(owner_section_id: self.section_id)
CheckoutSystemModels::Medium.where(owner_section_id: subject.section_id)
exit!
subject.section_id
exit
subject.send(attribute)
attribute
subject.send(attribute)
attribute
subject.send(:medium_model_class)
subject.send(:medium_model_class).all
subject.section_id
subject.send(:medium_model_class).where(owner_section_id: 1)
exit1
exit!
media
media.first
media.first.inspect
exit
medium
attribute
zeus test --format documentation spec/lib/mongo_models/checkout_system_models/survey_components/regional_press/paper_and_digital_publication_component_spec.rb
exit
zeus test --format documentation spec/lib/mongo_models/checkout_system_models/survey_components/regional_press/paper_and_digital_publication_component_spec.rb
exit!
media
subject.media_attribute_names
subject.send("images")
subject.send("images").first
exit!
media_names
exit
exit1
exit!
Respositories
Repositories::SurveyBlueprintRepository
Repositories::SurveyBlueprintRepository.all
repo = Repositories::SurveyBlueprintRepository.new
repo.all
repo = Repositories::SurveyBlueprintRepository.new
repo.find_active(:att_digital_creative_test)
sb = _
sb.presentation_type
sb.survey_components
blueprint = repo.find_active(:brainjuicer_ad_testing_express)
blueprint.survey_components
sb.label
exit
elements.count
exit
elements.count
exit
elements.count
exit
elements.count
exit
blueprint.translations.count
exit
blueprint.translations.count
language_chain
@lang_code
it
subject
metadata_item
metadata_item.fields
metadata_item.fields.first
metadata_item.fields.first.validdations
metadata_item.fields.first.validations
Products.all
Product.all
Product.all.map(&:code)
zeus test --format documentation spec/lib/product_definition/test_product_definition_spec.rb
current_product_setup
exit!
&block
block
page_number
page_title
exit
page_title
block
page_builder
exit!
@inputs
@pages_list
@inputs
page_title
exit!
@inputs
exit!
exit!
exit
subject.inputs
subject.inputs.nested(key)
subject.inputs.nested(key).inputs
exit
subject.inputs.nested(key).inputs
subject.inputs.nested(key).inputs.inputs
subject.inputs.nested(key).inputs.inputs.field_name
subject.inputs.nested(key).inputs.inputs.send(:field_name)
subject.inputs.nested(key).inputs.inputs.first.field_name
exit
subject.inputs.nested(key).inputs
subject.inputs.nested(key).inputs.inputs
exit!
expect(subject.inputs.nested(key).inputs.inputs.first).to has_attributes(:field_name input_title, label: input_label)
expect(subject.inputs.nested(key).inputs.inputs.first).to have_attributes(:field_name input_title, label: input_label)
expect(subject.inputs.nested(key).inputs.inputs.first).to have_attributes(field_name: input_title, label: input_label)
exit
error_message
exit
PricingAndTiming::Models::PriceAndTime.new(
  price: converted_price,
  time_hours: time.total,
  variables_used: price.variables_used.merge(time.variables_used).merge(exchange_rate_as_variable).merge(country_currency_as_variable),
  pricing_formulas_used: price.formulas_used,
  timing_formulas_used: time.formulas_used,
  incidence_rate: incidence_rate.value,
  pricing_formulas_values: price.formulas_values,
  formulas_to_be_exposed: price.formulas_to_be_exposed
)
exit
object
caller
caller.reject{ |st| st.include?("gems") }
caller.reject{ |st| !st.include?("zappistore") }
PP.pp caller.reject{ |st| !st.include?("zappistore") }
object
object.store_presentation_metadata
exit
object.section_metadata
object
object.section_metadata_list
object.survey_components_metadata_list
object.survey_components_metadata_list.attributes
object.store_presentation_metadata.inputs.has_nested?(:survey_components)
object.store_presentation_metadata.inputs.has_nested?(:sections)
object.store_presentation_metadata.inputs.has_nested?(:section)
object.store_presentation_metadata.inputs
object.section_metadata_list
object.section_metadata_list.map(@name)
object.section_metadata_list.map(&:name)
names = _
object.store_presentation_metadata.inputs.has_nested?(names)
object.store_presentation_metadata.inputs.has_nested?(names.first)
names.any?{ |name| object.store_presentation_metadata.inputs.has_nested?(name) }
object
object.store_presentation_metadata
exit!
object
exit!
&block
block
options
source
exit!
self.instance_eval(&block)
&block
block
exit!
self.instance_eval(&block)
name
options
next
name
exit!
self.instance_eval(&block)
next
exit
next
@sections_metadata_list
self.instance_eval(&block)
next
@sections_metadata_list
next
@sections_metadata_list
sections_metadata_list
exit!
sections_metadata_list
next
exit
next
sections_metadata_list
@sections_metadata_list
next
exit
page_title
exit!
next
exit!
object
exit!
object
exit
object
object.store_presentation_metadata
object.store_presentation_metadata.inputs
object.store_presentation_metadata.inputs.nested_inputs
object.store_presentation_metadata.inputs.nested_inputs.first
object.store_presentation_metadata.inputs.nested_inputs.last
exit
name(:sections, &block)
exit!
name(:sections, &block)
exit!
object
exit
object.section_metadata_list
object.section_metadata_list.attributes
object.survey_components_metadata_list.attributes
exit!
object
object.survey_components_metadata_list.attributes
individual_components_inputs
find_components_page.page
object.survey_components_metadata_list
object.survey_components_metadata_list.attributes
object
object.survey_components_metadata_list.attributes.merge(hi: 1)
exit
next
net
next
exception
object
object.survey_components_metadata_list.class
object.section_metadata_list.class
object.section_metadata
object.section_metadata_list
caller
exit
name
exit
exit!
object.section_metadata_list
object.section_metadata_list.class
exit
caller
exit1
exit!
caller.reject{ |x| !x.include?('zappistore') }
exit!
Metadata::SectionsMetadataList
ProductDefinition::Metadata::SectionsMetadataList
exit
ProductDefinition::Metadata::SectionsMetadataList
exit
exit!
object.section_metadata_list
object.section_metadata_list.attributes
object.survey_components_metadata_list
exit!
object.section_metadata_list
object.section_metadata_list.attributes
object.store_presentation_metadata
object.store_presentation_metadata.has_nested?(:sections)
object.store_presentation_metadata.has_nested?(:section)
object.store_presentation_metadata.inputs.has_nested?(:section)
object.store_presentation_metadata.inputs.has_nested?(:sections)
object.store_presentation_metadata.nested_inputs
object.store_presentation_metadata.inputs.inputs
object.store_presentation_metadata.inputs.nested_inputs
object.store_presentation_metadata.inputs.nested_inputs.count
object.store_presentation_metadata.inputs.nested_inputs.first
object.store_presentation_metadata.inputs.nested_inputs.last
exit!
object.store_presentation_metadata.inputs.nested_inputs.first
exit!
build_new_page(:sections, options, &block)
@titile
@title
builder = PageBuilder.new(@number, @title)
builder.instance_eval(&block)
builder.inputs
@inputs
exit!
exit
exit!
name(:survey_components, options, &block)
exit
name(:survey_components, options, &block)
options
exit
name(:survey_components, options, &block)
@title
exit1
exit!
exit
name(:survey_components, options, &block)
self
optinos
options
name
name(:sections, &block)
res = _
res.inputs
res
res.first
build_new_page(:sections, options, &block)
survey_components.first
exit
self
exit
eit
exit
name(:survey_components, options, &block)
res = _
res.last
res
res.last
exit
builder = PageBuilder.new(@number, @title)
builder.instance_eval(&block)
@inputs.add_nested(ProductDefinition::FieldCollectionSection.new(key, builder.inputs, options.merge(page: @number)))
@inputs.add_nested(ProductDefinition::FieldCollectionSection.new(:sections, builder.inputs, options.merge(page: @number)))
exit!
exit
object
object.store_presentation_metadata.inputs.has_nested?(:sections)
object.store_presentation_metadata.inputs.nested(:sections).inputs.each_nested.map { |field_collection_section| { name: field_collection_section.key, label: field_collection_section.label, css_classes: field_collection_section.css_classes, availability: object.survey_components_metadata_list.retrieve_component_metadata(field_collection_section.key).availability.to_json, template: field_collection_section.options[:template], fields: field_collection_section.inputs.map { |input| Website::ProjectSetup::InputSerializer.new(input, object.retrieve_component_metadata(field_collection_section.key), object.sources_metadata_list, current_product_setup) } }
}
object.store_presentation_metadata.inputs.nested(:survey_components).inputs.each_nested.map do |field_collection_section|
  {
    name: field_collection_section.key,
    label: field_collection_section.label,
    css_classes: field_collection_section.css_classes,
    availability: object.survey_components_metadata_list.retrieve_component_metadata(field_collection_section.key).availability.to_json,
    template: field_collection_section.options[:template],
    fields: field_collection_section.inputs.map { |input|
      Website::ProjectSetup::InputSerializer.new(input, object.retrieve_component_metadata(field_collection_section.key), object.sources_metadata_list, current_product_setup)
    }
  }
end
exit!
render json: current_product_setup_definition, serializer: Website::ProjectSetup::ConfigurationDefinitionSerializer, product_setup: current_product_setup
exit
exit!
components_page = find_components_page(:sections)
_.page
object
exit!
sections_metadata
sections_metadata.first
sections_metadata.first.name
sections_metadata.find{|section| section.name == section_name}
exit!
object.public_send(metadata_list).retrieve_component_metadata(field_collection_section.key)
exit!
object.public_send(metadata_list).retrieve_component_metadata(field_collection_section.key)
object.public_send(:survey_components_metadata_list).retrieve_component_metadata(field_collection_section.key)
exit!
object.public_send(metadata_list).retrieve_component_metadata(field_collection_section.key)
object.public_send(metadata_list).retrieve_component_metadata(field_collection_section.key).availablity
object.public_send(metadata_list).retrieve_component_metadata(field_collection_section.key).availability
object.public_send(metadata_list).retrieve_component_metadata(field_collection_section.key).
object.public_send(metadata_list).retrieve_component_metadata(field_collection_section.key)
object.public_send(metadata_list).retrieve_component_metadata(field_collection_section.key).class
exit
configuration_metadata
input.field_name
configuration_metadata
exit!
configuration_metadata
input
sources_metadata
exit
input
configuration_metadata
caller
caller.reject{ |x| !x.include?('zappistore') }
exit
exit!
field_collection_section
object.class
object.retrieve_component_metadata(field_collection_section.key)
field_collection_section
field_collection_section.key
object.retrieve_component_metadata(:section)
object.retrieve_component_metadata(:sections)
object.retrieve_component_metadata(:survey_components)
object.retrieve_component_metadata(:survey_component)
metadata_list
exit
field_collection_section
exit
field_collection_section
field_collection_section.key
object.class
object.method(:retrieve_component_metadata)
object.method(:retrieve_component_metadata).source_location
field_collection_section
field_collection_section.key
object.retrieve_component_metadata(field_collection_section.key)
object.find_section_by_name(:some_section)
exit!
exit
field_collection_section.key
get_component_metadata(field_collection_section.key, type)
exit
exit!
input
input.label
exit
input.label
exit
input.label
exit
input.label
exit
field
field.name
exit
field
field.name
exit
field
field.name
exit
field.name
field
inputs
input
exit
ProductSetup
Website
Website::ProjectSetupBaseController
Website::ProjectSetupBaseController::ProjectSetup
Website::ProjectSetup
Website::ProjectSetup::Cart
ProjectSetup::Repositories::CartsRepository
ProjectSetup::Repositories::CartsRepository.all
result
result.value
definition
definition.class
product.code
exit!
definition
exit!
exit
exit1
exit!
product_definitions_repository.find_product_definition(product.code, version)
product_definitions_repository.class
product_definitions_repository.all
product_definitions_repository.find_product_definition("test_product")
version
product_definitions_repository.find_product_definition("test_product", 1)
def = _
definiiton = _
exitQ
exit!
section_metadata
definition.section_metadata_list
definition.section_metadata_list.retrieve_section_metadata
definition.section_metadata_list.retrieve_section_metadata(:some_section)
section_name
rspec --format documentation spec/lib/project_setup/factories/sections_factory_spec.rb
exit
section_metadata
exit
exit!
section.class
section.name = 'test'
section
section.extend(Virtus.model)
section.name='llol'
static_attributes
exit
subject.method(:concept_test).source_location
subject.concept_test
exit
definition
exit
exception
exit
publications
translations
source.answer_options
next
exit
generated_thing
exit
questions
exit
Survey::Null
Survey::Null.instance
exit
exi
request_http_basic_authentication
username
password
exit
ProfilingConfig
ProfilingConfig.username
ProfilingConfig.password
DisplayContext::Null.instance
DisplayContext::Null.new
DisplayContext::Null.instance
SecureRandom.hex
exit
translation_keys
blueprint
PP.pp.blueprint
PP.pp blueprint
exit
blueprint_name
exit
cache.delete(translation.lang_code, translation.key)
translation.key
translation.lang_code
Rails.cache.delete_matched("#{ lang_code }*#{ key }*")
exit
current_customer
agent
request
request.subdomains
request.subdomains.first
current_branding
current_branding.method(:billing_information)
current_branding.method(:billing_information_form?)
current_branding.method(:billing_information_form?).source_location
current_branding.method(:code).source_location
exit1
exit!
form
order_creation_data.class
order_creation_data.product_setup
order_creation_data.product_configuration
checkout_session.product_setup.product_configuration
checkout_session.product_setup.product_configuration.class
checkout_session.product_setup.product_configuration.inspect
checkout_session.product_setup.product_configuration.method(:ad_type)
checkout_session.product_setup.product_configuration.method(:ad_type).source_location
checkout_session.product_setup.product_configuration
exit!
order_creation_data
order_creation_data.product_configuration
order_creation_data.order_details
order_creation_data.order_details.class
CheckoutSystemModels::OrderDetails.all
CheckoutSystemModels::OrderDetails.find({})
/^[A-Za-z0-9]{1,20}$/.match("fhue9pu23gh9ruhg3")
/^[A-Za-z0-9]{1,20}$/.match("fhue9pu23gh9ruhg3!")
exit
form
form.class
next
exit
result.has_errors
result.has_errors?
result.errors
result.class
exit!
order_details.method(:validate_reference_number)
agent.current_checkout_session
order_details.method(:new)
OrderDetails.method(:new)
CheckoutSystem::OrderCreation::Models::OrderCreationData.method(:new)
CheckoutSystem::OrderCreation::Models::OrderCreationData.method(:new).source_location
order_details.paras.fetch(:order_details)
order_details.params.fetch(:order_details)
up
exit!
caller
caller.reject{ |x| !x.include?('zappistore') }
caller.reject{ |x| x.include('gems') }
caller.reject{ |x| x.include?('gems') }
exit!
exit
order_creation_data.order_details
order_creation_data.order_details.valid?
order_creation_data.order_details.validate_reference_number
order_creation_data.order_details.reference_number
order_creation_data.order_details.billing_information
exit!
validate_reference_number
order_creation_data.order_details
current_branding
next
order_creation_data.order_details
order_creation_data.order_details.validate_reference_number
exit!
order_creation_data.order_details.validate_reference_number
current_branding == "millwardbrown"
current_branding
exit!
order_creation_data.order_details
order_creation_data.order_details.class
object.store_presentation_metadata.inputs
page
pages
object.pages_list
object.store_presentation_metadata.inputs
object.sources_metadata_list
exiT!
exit!
object.sources_metadata_list.sources_metadata
object.sources_metadata_list.sources_metadata.first
object.sources_metadata_list.sources_metadata.first.source.get_data
object.sources_metadata_list.sources_metadata.first.source
object.sources_metadata_list.sources_metadata.first.source.service_class
object.sources_metadata_list.sources_metadata.first.source.retrieve_source_data
exit!
sources_metadata
ProjectSetup::Sources::PrimaryActionsSource
exit
exit!
object.sources_metadata_list.sources_metadata
object.sources_metadata_list.sources_metadata.first
source = ProjectSetup::Sources::PrimaryActionsSource.new
ProjectSetup::Sources::PrimaryActionsSource.method(:new)
ProjectSetup::Sources::PrimaryActionsSource.method(:new).source_location
ProjectSetup::Sources::PrimaryActionsSource.get_data
exit
product_setup
caller
caller.reject{ |x| x.include?('gems') }
exit!
source.retrieve_source_data(current_product_setup)
current_product_setup.product_target
current_product_setup.product_target.country_id
ProductConfigurationAttributes::Repositories::ActionGroupRepository.new.for_country_id(1)
res = _
res.first
res[1]
res[2]
exit!
caller.reject{ |x| x.include?('gems') }
exit
exit!
'which_of_the_following_tv_and_or_internet_service_providers_are_you_currently_subscribed_to_if_any_se_c96a86bfa84a13097d27cb1cc7494c506027baf2_7'.length
'c96a86bfa84a13097d27cb1cc7494c506027baf2_7'.length
xml.xpath("//variable[@ident=#{question_ident}]/name[.='#{name}']")
xml.xpath("//variable[@ident=#{question_ident}]/name[.='#{name}']").present?
exnt
exit
xml.xpath("//variable[@ident=#{question_ident}]/name[.='#{name}']").present?
exit
ProjectSetup::Cart.destroy_all
Website::ProjectSetup
exit
Website::ProjectSetup
Website::ProjectSetup::Cart
ProjectSetup::Cart
ProjectSetup::Cart.destroy_all
a = {"file_data"=>"PK\x03\x04\x14\x00\x00\x00\b\x00\x13\xA2\xC6H]\x15\x85\xBCb\x17\x00\x00\xD3\xA8\x00\x00)\x00\x00\x00temp_146524419720160606-15058-1085bsl.xml\xE5]\xEB\xB2\xDB6\x92\xFE\x9F\xA7\xE0j\xAB2?6:\xE2E$E\xCF\xB1\xB2\xBE\xC7U\x8E\xE3\xCD\xB1\x93\x9A\x99\x9ARA\"$1\x87\"e^\xCE\xB1\xF2k_c_o\x9Fd\xBBAR\"$R\x00$\xC4;S\xE3\xF2\xA9\x92\xC8\xC6\xE5\xEBn\x00\x1F\x1AM\xEA\xF6\xFB/\x9B\xD8x\xA0Y\x1E\xA5\xC9\xD3\x81uc\x0E\f\x9A,\xD20JVO\a\x9F>\xBE\x1EN\x06\xDFO\xBF\xB9\xCD\xF3\xFC e\x83\xD4\xF4\e\xC3\xB8\rIA\xA7\xB6iyC\x13\xFF\xDF\x8E\xD8\x05\xBCSD\e\xBC\xF3\xC4\xF2\x9E8p\x9D}\xC5\xEBi\x16\xAD\xA2d\xFAW\xB2\xDDFy\x91f\xD4xI\nb\xBCH\xE3\x98.\xE0\xFB\xED\xA8\x96@\xE1\x7F\e\x0E\x8D\xDB\xBC\xCC\x1E\xE8n\xB6H7\xDB4\xA1I\x91\xB3[\xC7W\x8D(|:\xA8z\x05w\xB7\x19\xCD\xE1\")\xA0\xBB\xB3b\xB7\xA5\xD3]Z\x16\xE5\x9C\xCEB\x9A\xDF\x17\xE9v\xF6\x10\x854\xBD\x1D\x9D\nV\x15\x84\xF4!Z\xD0|Z\x8B\x03\xB0\xFABu\xBB\x88\x8A\x98N\xEF^\xFFl\f\x8D\xBF\xA4ef\xBC!\ejD\xB9\xF1\x13|~G\xE6\x86\xF5\xC4\xB2\x105\x8AUE64\x8C\xC8\xAC\xCC\xE2\xE9\xBA(\xB6\xF9\x93\xD1(wn\xC8\x86\xFC\x9E&\xE41\xBF\x01 #\xF8\xBB\x89\x92\x822U@\x87\xF2tY<\x92\x8C\xDE\xFC\x8E\xDA\xBAa]\xBE\x01\x1C\xD0\xEB4,\x99\xC8\xA8\xC8H\x92\x83\xB9h8\xABZXF1\xCDG\x93\xA5\xE5\a\x9E\xED;\xAE\xE9\x85V\xE0\x8F\xED`\xEE\xB9!\r&\xC4\xF2\x82\xF9|n\xB9\x01%t1\x8A\x92\x90~\xB9\xD98\xE5\xE4vt\xE8b\x8Dr]n\xE6\t\x89b\r\xDD\x8E\x12\xAE\xD7M\xCD\xF9\xC86\xCD/\xF0'\xDD\xE3\x9BM\xFAp\xF3\xDBvu;\xE2\xBBWu\x99\x84\xE0\xA4\xC5l\x99f\eR\xCC\xA2p\nV8\xB9V\x89f\x806\x83\x1E\xEF\xC1\x016\xE8p~Cwt\x98\x7F.\x11\x01\xC2\xCB\x17k\x1A\x961\xCDF\xE0(\xD9\xEE\xFB\x0FY\xFA\e\x14{\xFB\xF2i\xED\xF8\xB3\xBF~0Mg\x16\xA5_\xBC\xD5\x82\xEC&\xD6\xB7d\xB3\xFD\xF3]9G\xB17YZnAv\x19\x8Cm\xD3\x0F\x16CB-g8\x1E/\xCCa0\x99\xBB\xC3\xA5\xED\xD8\xCB\x90\x12\x8B\x84\xF6\xED\x88\xEBS\xD5M\xE8M\xD5\x99Y\x8D\x03\x00\xC8U\xD6U\xB2\xAA\x93\x99d\x16\xD3dU\xAC\xA7\x1E\xA8\x88\xBB\x80\xC3kt<\xBE`\n8\xB9\x86\xA3a8<\x8C\xD4-Ih<\xCB\xA3\xDF\xE9\xD42M\x18\\\x87\xEF\xBC\xE0\"-Q\x953\xF4\xDB\xE9\xA7\xBB\xDB\x11w\x81\x97%\x0F`a2\x8F\xE9,&\xC9\xAA$+\x18\x84\x7F\e|\xBA\x9B\xD1d\xF0w0n\xC7m\xBE\x82\xE6z\xD3\x1A\x14\xBC\x1D\xF1\x17\xF9\x02\x19]\xE1l\x10\x85\xF9\xD4\x1A\xDACP0\x1Af\x7F\xED\xA8\xF6tQM\x1E+44\x9BB\xAA:\xA1\x8D\xBE[|\r+\nC0C\xE3\x80\xCA\x0E_x\xA1\x82d+Z\xD45Un}|\xE9L\x81\x04f\xA7\xE9{\xD6\x19\x12\xC7;\xE3gz\x98\xF7\x1E\xA8q\a\xFE\x1A\xD3\xA3\x1AY\x99N\xFB\x96\xDBm\x1C\xD1lj\xEF-\xDC\\9\x12\xAF\xC6{\x859\x8E\x92\xFBY\x92>\xCEB\x98\xDD\v\x12\xDF\x8E\xB8\xDB|\xC9y\\B\x0FaN\x99\xFE\xFB\xB7q\x01C\t\xFD\xEEys\xF1\x89\xF9\xC54\xFD\xE5\xC4\xF2,\xCB\xF7\xE7\x93\xC9\xB7\xAB\xE2\xCF\xB7\xA3C!\xBE\xB24\xAB5j\x9B\x13\xC7\x9A\xE0\x02\xD3\xA9\xE2\xEA\xF2\"\xA3\xB0\x84\x853R\xD4\xEB\x9A;t,\xC3\xB6\x9F\xB8\x93'\x8Eo\xFC\x87\xC9<\xFBD\xB6\xB3*\xD0IRT\x8A|C\xD3\f<(7\xEE\xEEa\xB9 \xF9\xBE\x8A\x96\xCC\x99:\xE8\x06\xBC|\xBA\xAA+\xB9\xC9\xABJ\xFEs\x13\xC51\xCC\xB4\xE1<K\x1F\x13\x9C\xAC\x8E\xAA\xAD\x8A\x9DX\x05\xE7\xA5Y\xB56\xBD!\xB0\xE6\x92\x10|@\xB4\x96\xF1\xE5\xF8:\xCB\x1C\xDAdn3]\xD5\x15\xDE\x8EZ\x17\x8FF?(m\x95\xC2hg\xA8\xEF\xB6iV\xE4\xC6K\xB0\xDC=\xA8\x85\xBFy\xE4\x16\xB0\xD6\x85\xB5>\xF7\xCD\xB4.v\xBB\x1F\xBBup\xB7\x0E\xC9\x05\xACY\xE5\x06zK\xD8\xEA\x84\xAE\xF17\xFB\xEF8+\x9D\\\xEF\xF1\xF0\xA6\xD3\xD5\xC8\xEC\xBA\xCC\x17\xBC\x87itC\xF3\xBC\x9E\xAE\x90\x1D\xB0/\xD3\xB7\xB9A\x8C\xBCR\xC9\x96fl\xCDJ\x16`\x8E$I\x1F\b\xE3G\x8D\xE8I\xB1\x98\x82Bz\x04\xDE\xC08\xCF\r\xB0+\xE1\xAA\xA5\xE1\x8A\x1A\xAD\x12\xB7\xA3\xA3\x9E\xB5;}XO\x1A_`\x83\xAA{\rl/?-\xF1\xE3\x99vI3`\x9Bt\x96\xC0R\x8ES\xCA\xC42\x03\xDF\xB1p\xC2=\xBA\xC5\x95\x94\xF9|\xFB\xB9L\vR\xA9\x170/p@\xC4\x94>\x92\x1D\xACN`$\xFE\x12J\xB1\x02\x06:\xC8\xD3A3\xA7\xB1\xE9\xA9\xA1\x95L`\xF6@`\xA6\xA9\xAE\xE0Z\xCA\xBE\xB9\xCE\xD8\x87e\x94\xBBS\xB7\x80\x8A\x1D\xBB7\x87&k\xDB0\x196\xF9U\x85\xEBy\x10\xAF\x8EN\x1A:\xD7\xB4k\ag\x9A\x0E\xCC\xB3M\xB3\xC2\x977=\x9E\x9Ci\xDA:\x8F\x9A\x15>\xD3t}\xE1\xC44\xD5\x1A)\xB6\x89u\xA6k\xFEY\xADX\x97\xAB\xC4>\xD3\xA8s\xB6Q\xFB\"e@5\x12\x9A\x98\fm\xF7L\xC7&\xFEYmT\xA5/\xD6\x887t\xCE5\xEE\x8D\xCFj\xA5*-\xA3\x99\xFA\xC3\xD1\xB4\xD5|\xAE\xC8+\xB7\x7F\x93_\xFC\xDA\e9\xE0\xE7\xB0\xC8\xC2~\x13\xBA\xFBt\xF0l`T\e\x8B\xA7\x83e\xF4\x85\x86\x83\x16\xFA,Bb\xDAH\x9A\xF0\xCF\x1A\x18H\x03\x9F\x0E\x16k\x92\xC1\xAA\xB2wcV\x82-M\x87\xC9\xF2vT\xAFU\xCD}\xE0\xB94\x9E\xD6\xFB\x0F\xE4\xB0\xF8\xF5p\x9B\x11m\xDB\x05m\xD5\x94\xBB\xB9\xB1M\xF3\b\x170#\a\x86\a=\x81^,\xA3$\xCA\xD7\xB0\x93w\xDD\xC1h\xDF\xE5Q\xD3\xE7\xB3 l1\b`\x97\xB0E\xC0\"\xFD8~\xDE\xCB\\\x01\xC5v\xBD\x03\x18\xD72\x95\xC18\xB2`r*\x82\x92S\xE3\xED\xCB+\xB0\xB8V\xCB0\xBE\xA7n\x98q\x83\x05\x96\xDD\x04\\vw\x02\x05\x86W\x0F\x84gx\xA7\xB3\xEB\xB8X\nz\xEE{-+\xF8\xBEz\xCF\xDD\xA6\xE7y\x94\xACbz\xD2\xEFj\xCA\xEF\xE9zs\xB3\xBB\xF7\xE2\xCE\xFB\\\xE7\xBDC\xE7\x9B),?\\h.\x198!\xE1H\x9A\xFEHp\xEB\xC4\xCDn'b\xF6`\xFA\x1A\xB8x\x87`}!W\xD4\x97'\xD0W\xB5]\xED\xD1\x17\xDC\xC4=\xF7\xC5\xEA\xF2\xDB\xEA\xF2\x15\xD5\xF5\x1E\xA8\xED\xDAxE\xF2BBi?F\xA1\xF1+\x15\x8B:\x83\xE9]Z\x16k\x91\xDCx0\xED\xAC\xEEB+\xF8\xC2\xF1\xC6t6\xC3\xE0g\x8F-\xEEP\xC0\xF8\xC8\x04.\x1E}\xFE\xA4e\x91\x89\xAF<\xFA&B\x1C0\xC2\xCE\xA1x\x95\x84\xD7b\x98\xB41\x04\xEA\x18\x02!\x86\x10\xB6\xCC\xD56.\x99\xE5\xB0\x86'a\xDE\x03\xE7e-y\x05\x9C\xA0\x05gb*\xC3\x81\x85L\xB8,\xE1\xA6\x1F\xB7\xD8\xF8\xA5\a\xC8\xF3J\xC4xOzm#\xB30M\xCC\x16\x1A\xCB\xF4le8\x12\xBC\xA7\x81S\x1F2\b\x10\xFD\xD2H]N\x82L\xCFi\xA1r,u#I\x10\xA1\x14x-\xF8R\xB2\x9A\xE5\xBB\xBC\xA0\x9B\x1EX?5b\xC6]-v9.\xC7j[\xCB\xF5\xD5\xAD\xE5\b\xC7RE\xC1\xA1\xC5\xA2\xEC\eD\xFF\xC56)w\xB5\xC8\xA5\x03\t\xFA\xDF\xB6\x92;QG3\x16\xAC\x95'Q\xED\x1E@\x1F\xD7\xD4\xA8d\x8D\xC3\xA9S\x01\x17\x0Fd\xD7 I\xFEH3\x1A\x1A\x9Fa5ag!\x06\x99\xC3\xCAt\xF1j\v\x88y\xFC\x8E\xCAzk\x0E\xFA\xCE\xBD\xB4,\x80\x96\x88\xB6\xB1\xA0o\xBE\xC8(M`d\xE7\xB4w\x15\xA4\xBDK\x87\x8C\x86\xC6\x9C\x86\xC6\x8A\x8C\xE4/4\x97\xA0\"\xEF\xB5)M\xC4\xDDx\xA5\xAD)\xE9\xE3\xBD?\xB0[\x97\xAB\xCD\xE5\xD4\xE6\xFE\x83\xAB\xCD\x97Q\xDB\x92,\xE8<M\x0F\xFA\xEB[\xE1S\x03\x06\x86\xB1&\x0F\x18\x11}]\x972\xC8\x82\x1DD}\x7F\x8DV=N\xAB\xAA\xBB\x89\xAF\xAD\xD5\x89\x92V\xCB\xBC\x7F\x03\xF9\xEB:Z\xAC\x8Dt\xC9\xA6\xC4e\x1A\xC7\xE9#\xAEgs\x98\a\r\x98|\x16Y\x04\x1FQ\xEB\xD9A\xDF\xAC\xBE\xAB\xB4\xEDs\xDAV\xDD\x8C\x8C\x87\x9E\x81\xB4\x96\xC5\xDA\x8D\x90\xEC$to\x0F\x1D\xB52\xB09\xF9\tc\xEDDF\x18v(\xCF\x8C%}l5\xF1H\xE9\xBD\xA8\x98\xBBoCF\xDA;md\x93&\xE2\xED\x93?\x98\xBE\xA3y\x0E\x16&\x89\x91b{\xFDE/\xF4\xC7@\xC6\x1F\e\xAA(\x18\xE4\x1F\xD7Q\xDE\xAC\xD8k\x02\x1F\xD3\r\"I\x8Aj\xE1&\x05\xAC\xDC\x9F\xCB\b\x96o\xE3M\x9ABk\xC6\x8Bu\x862)\xB8(\\^\xA6_\x8C\b\x80\xE2\x89\x9AQ\xA4FV&7\xD7\xF8*G\xCB\xE0\x9B\x9A\xAFr]\x94\t8T\b$\xBC\xF3Y\x92\xC2\x98\xCD\x8CZ\xAD\x9ALi\x9B2\xA6\xA4\xC9o\xE9n\xC3b\x80\xDDk\\\xFAhlJ\x98X\x1E\xD32\x0E\xD9\xA4\xCD\x8A\x18\x8F\xA4X\xACq\x82)\xD0\xCA$4(\x01)th&\x04\\\xC3\x88\npRh\xE5\xBA\x19&\xE0\xAC\x16(Z\r\xF6);\x06@\xC2bw`\xD8GpK\t\x93\xFD\x8A\xDAH\xFET\x18\x9B(\t%\xE6\x94\xF7i!\xD5\v\xB7\x12\x85\xA1A\xE2X\x97#X2\x8E\x80G\xAC\x0F\x14\xF6\xE6\x0Fi\xFC@\xD1#fV_\x00<\xA6$\a.N1\xDF\bLL\xC19\xB2\xD0X\xC2\xC0\xA8\xBC\xA0Z\x84@\xA4X\xC3\x04a\xC4Q^\xE4\xD5\x80'\xECP/\x879\vV%\x18\xD2\xB8V\x91\xF0\x9AQ\x1D\x98m\xFF\bL\xD5pX\xB4\x90\x19\xCCoa\xD2\xCApG\x91\xAC$\xBC\xE3y\x9AI\b\x82[\xBC\xCD\xB2\xA8 \x9D\xB5^hk\xFBB[\xDB\xFF\x14\xB6\xB68[[\x8A\xB6\xBEKa\x9E\x950\f\xD8\xFBS\x12\xC1\x0ER\xC2\xD4/\xCB\x8Eqzj\xE8O\xC9\x16\x15I\x12]\xB1O\xDB\xB9\xD0\xD0\xCE?\x85\xA1m\xCE\xD0\xB6\xEA\x91\x00E\xF6+5\xACQ1r\x83\xFAWJ\x84\xC4\x0E,\xFD\x12\xF4Rfs\x8DCZ\x14?\xA9\xF6\xAB\x05IB\x92\x853\x96\x8E\xC3Z\xEF\xE3d\xC9=.\xDB,,R\x9B\nW\xEC\xFF\xFD\xEF\xFF\x81\xBD\xD8o%\x98\x10\xD6\xEE\x04\x0FU\x8D\xE6|\xF6;\xE3\xB1\xDA\\\x80W\xEC\xDD`\xBB\xCE\xC0a\xF2\xBD\xF5\x99\xE1\x19\x15\xB8f\xB9\x0F\xB8hK\xA0\x14m\xC1\xED\eP\x8FE\xB36\xAFi\xBC5\xE6%\xD2\xCC\r\xC5\x1C\x16d$\x8F@D\xDB\xD8d\xBC\xA4\xC0\x03\xE9mF\x8Bbg\xAC\xD24\xC4\xF5yC\x98\x1A\x91\xEB\xB4\xAB\x8F\xD4jw\x9A\xDA\x99\xE2\xD3{\xB2\xD3W\xF7\x98\xD5\xCD\xB4Qm\xB4\xE7\x8D]I\xB23\x98\x9F\xA05\x8F\xF2\xBF\x84\xFC\xA4\xAF\xCE\x98\r\x7F\xA8\xBA{\x8E\xBD\xD0\xF9\xE5\"\\\x18XK\xB3Y\xB4J\xD2\xACo\x7F\xFCv\xC9\x14\x8A\xE1A\xF4U$\xA8\ru\x05\a\xC4\x8D\xDB\x1C\x9C\x11|=\xACb\x13\b\xE3\xBE*\xC2\xE0b#\x06\xEA,f\x91\x8A\x82\xD1[\xB0\vk\x13?-\xE2\x94\xCD\x8ElD=F\xC5\x1A\a\x18\nC\xCF\xAF\x1A\x12\\x-P\r\xAF\xDDq\xFD\x96q\xF7#D\xA7ht\x19W*\x12\xC76\x1Ah\xDD\xFC>\xDA\xFEA\xB6em\xD4\x06-`\xC3\x00uT\xD8\xE1;6[[\xF5*+r\xD1\xBE@5\xDA\xF7k\xD3C\t\x03~\xECG\xA0\xCBrR\xC1@6,19\x14\xDD\xE6\xBC\xE5\x16\x98\xF5C\x16Y\xCA\xA2\e\xCCr\xDF\xD5\xB6\x89\xD8|X\xED*\x1FI\xC2\x18\x06\e\x8B\xB8U\xC3\xAB\x7F\x02\xA3\x87)[\xD3\xB8\xD1y\x95\xB5\xB8(b\xA0\x1AE|I\xB1pAc\x99\x80\xD6\x87,\x9D\x83~e\xE2X\x8D\xA8\x91\xA4\xC2]\xEA\xB8\xDD\x8D\xCE\x02\x17\xDA^.d\xB9Y\xAC*.r6hyW\xD1Mt\xCE\x8AO\xD4L\xA3E*X\xC4\xB2\xCC\x19\xF3h\x96\xBE\xAB\xB8%\x17\xB2\fTC\x96\xCF\xCB\xDD\xBE\e\x15\xE3M\x97\x05>\xD1 \xB43W2\xA3\xAB2&\x99\x94\xD5\xB9\x82\x8C\x90\xB30\v\x12\xAEH\x1C\x8A\x1A\xE3\x84\x10\xD1\xF0PE\x94T\n\x97\xC8\x01\x81\xF5\x1EO9\xC2\xB6\xF2\x19\xA5J\xE8\x03\x06\xE5X\xC5Q1\x82\xFA6\x12Q\xCF\xF7\xAC\xD4\xFA\xB4F\xBAd\v\xB7\x1E\a\x95\x8Aa2\a\xDD\xD2,/\t\x1Ed\xCF\xCA\xBC7\x8E\x891\xB0\xC7(\x8E\x9B\xB5\x9D,\x97\xE8\xB4]\x8Ey\xD5\x9C\xC3\xC5'\x03\xD5\xF8\xE4]\x91\xA5\x00w\xC7\x9E\x1E,3\xCC\x1F7*/\xC1\x90k\x94\x94h\xB8\x1DN\x93\n\xD4\xF7\x95\xAE\xBA\x1CL\xD4\xBA\x87j\x92\xD4\b\xA3e\x9D[.\xE1\xBBU)h<\xC6\xC8w\x1C\xDD\xE3l\xA6\xD2\x91\xCB\x9C\xC8\x91\x8A\x9E\x1E;\x11\x8C\a\x12\xE3\xCE\xF8\xFF\xD9\x93\xB8\x98i\xA0\x1A3\xDD\xAB\x9C\x05~7H\x069\xBD\xE7\x11\x06\xE4\x17\xEB4\xCD\xDB\x9A7\xC8\x8AD2\x13\xE1\xBE~\x02\xF5\x16ELu\xB7\xA1\xDF\xD9\xB0\x1FT\xD4\x8B\v=M*<{\xECi\t\xB8\xFF?\x84\xB3yf;\x00\x8B\xDF4:\er\xF1\xE3e+\x81\xD5\xC3X\x96E\xD9\xB1`\\\xE0kW6\xA1\xDD\xD5T\xFBs\xA1\xD3I\xC5\x89+\xFE\xD6\x86\xD5\xEBhy\xB3\xFA\xD4;,\xB2\xC2 !l>\xC2(\xAF>\xB3Pa\xED\x8A\e\x06\xFE\xB0\x13c\x94\xBF\x8AH\xC0\x87\x8C\xB2\x87$\x9Bv\x8B\x8A\xF3\xB03\xB2\xFC*O\xB58OU\r\x1F?c0\x1A\xA0\x12\xBEW\x17\x88\xA3\xD5\xBA\x90\"z\xEFi\xC4\x0E\x02+\x85%-\xED\xC9\x05\x1E\x89R\x83n\xBBL\x1F\xAA\v\xDDK\x9C\xC1V\xC5\xA7\x97l\x83\xB2\xEBs,\x82\xB1\xD9*\x1EYy\xCEw\xC6\x1A\x9C\xAD\xF6\xB1%\xA5q\x1D\xC7\xDCOd\x9F\xEA\x10\f(!de\x17$f\xC4e\x85\x0F\xDA\xB2\xB9\xAF\xCA\x11\xEB\xDDBH\xE4\xC4yf;>\xEDY\xBC'\x81\e\xAF*\x9E\xCE\x9E\xF4(R\xCCuT~0\xC2\x91\n\xFBn\xA1\x95->\x02\em\xF0\x89b\\\x1A\xF2Y\xEB\x11\xC2\xDE3\xBC>\xD5\xD6\x13\x11\x8C\xC2\xA8>\xA3\x1F\xECg#\xE1\xB3\x91\x83j\xBD\xC9\x8Bhq\x8Fs\x17S7\x9E\x90^3j-^\xD7\xAAg\x01\xEC\x00\xB8B\xA5p\x04,Y\xA2\xBD%\x7F\xAC\xC3\xCEj\xFB\xF2\xDER\x17\x0E<\xA9x\xA9\xD0k\xFAN\x03\x9F%\xB2nR=\v\xFB\xC78\x84\xC39\x84\xEA\x11\xC1\xBF\x98CH\xC5X\x85\x0E\xD1wj(\xE5\x10\xE7\x9E}\xFEc<d\xCCy\x88j\xC4\xFC_\xCCC|q\x16}\xB5X\x87\xB3\xBC\xDClH\xD6\xB7\\\xD7G\xC8\xF8\"\x1A\xD8`0\xB78Z\xA6\xF7A\xF9\a\x9A\x01\xC7\xFBn\x1F\xC3e\xCA\xAB\xE9\"\xFBX\xC9G\x05\x8B\xE96\x87J\x06\x8Ds\xDA\n\xDB3I\f\a\x93]s\xEE\xBC\xA5\xE96\xC6(b\n$\x13\x19t\xD1\xB7\xD0K\xE5\xF2{V;l?\xF1\x02\xE5e\\\x14-m\xDE\xD70\x8B\x92|\e\xD5O\xC8\x90\xA2`\x96\xE8{\xDE\xF1\xD9\xE1\xFE\xA5\x83d\xE2\xB7\xF7m\xF8M\xF592\x89\xB1\xD1\x95M{\xA1\x97\x8A\x82z\x9Dz\xA4_\x16Q\xBF\x16_5w/\xD7\xA1\xC5\xE9PuG\xF1\x95u8\x16\xC5\xB4:u\xB8H\x93e\x14\xF6g\b\xBE8\xDC\xBF\\\x8F6\xA7GU\x8E\xF7\xB5\xF5(\x8A\xD8\xF4\xE9\x11\x13_{\xBD\xF1\xC5\xE1\xFE\xE5zt8=\xAAR\xA3\xAF\xADGQ\x10\xA2{nda,|\x93R\xD1\xFB,5'r\xB96\xC7\x9C6Ui\xC4\xD7\xD6\xA6(#\xACS\x9B\xC0\xFC\xCA3/:(\xAF\xF2Fn\xED\xF4U\x8F\xBC\xBF\xB6\xFED\e\xEEN\xFDU\x9F{\a\xF5\xDB\xFD\xED\xCB\xB5\xE8qZT=\x8A\xFE\xDAZ\x14\xBEI\xA0K\x8By\x99m\xB3(\xEFU\xE3\xDD\xE1\xFE\xE5z\xF49=\xAA?7\xFFu\xF5\xE8\t#h,^\xFA.]\xA5\xB3\x171\xEC\x9E\xF0\xF9\xEF\xDEp\xCFs\x94\x8DA\xD6X\xA0lq\xD5\xB3\xE2\xA0\xBD\xF6Q\xE5D\xFD\x89\xF7\xB1\xF8\xC9}\x86\x0E\x9F\x9B\x96E\x87w\xF4\xA0\xE3\x1E\x14\x99\xA8?\v?\x16?\xCF\x0F[\xAD$\xA1\xB1$\xBE\x17\x95\xB4>\x84\xDCQs\xA0\xFEx\xFCX\xFC\xB4?\xBEP\x96ls:;\x8F\xAC\x962\xAED\x14pO\xC8\a\xEA\xCF\x92\xBB\xA6\xD8f\xE9\x063\xA8\xE7eQ\xC0\x94%a\xB5\xB6\xBC\x16\xBB\x05\xDC\x93\xE5\x81\xAD\x8E\xD2\x12\xA3,\xB3<\xCD~\xC0\x1D\xFA\xACy\x0FC?D&\xBCFa#\xBC\xFA\xA5\r\x80\x88\xC3\xE7\xA8\xE3\xB3\x95\xF0\x9D7_\v\xDB\xB5vs8\\cu\\\xE2\xF3\x94W_\xB6xXw\x16R%s5\x9A1\x87\xC6UG#~O\x12e=}.;\xD4*`:G\x9A\xCBa\xF4\xD41\xBAB\x8CK\xF2\x90fQA\xA5Q\xBE\xAE\v\xE8\xC4\xE9q8}u\x9Cb\x9E\xB2&\xF9\xFA#YI\x00\xFC\x01$\v\xB2\xD2\x83\x8C\xE3(\x81:Gq\xC5\x1Ce\r\xD2\xD2\xD6\xFB\x01\x84uZ\x8Ec)\x81:Kq\xC5,%\xDA`\xEC_\f\xED-\xCA\xE9A\xD5f&\xB6\xA9\xCEL\\13a\xC1l1\xA8w\x98\x98\xA0\x01\x93m\x9A\x1C&un\xE2\x89\xB9I,\xB7\rx\xA7i\a`\x9B\x16\x87I\x9D\x89xb&\x82\x89:\xD2\xA3\xEBG\x10\xD67\xBAl\xD3\xE6\xF0\xA93\x11O\xCCD6\xA5\xC2\xDC\xFFc\xA9s\xDE\xB7M\x87\xC3\xA7\xCEH<1#\xD9\xC2\xA4\xF0.\xBA\x97\x99@>\x80(;\xCC\xD1\x82m\xCCaS\xE7'\x9E\x98\x9FlI\x99\xCB\e\xEF\x03J\xEB\xB4\x9E\xCB!Tg'\x9E\x98\x9Dlc\xB2\x9B\x93\xC5\xBDx\x13\xF0\xA1\x96\xD4\xB0\x03\x00,\x1C2u>\xE2\x89\xF9\xC8\x1E\xD9\xDD}\xB4=o\xB7\x06\x19>As\xAD\xCD|\x0E\x99:\x1F\xF1\xC4|\xE4\x80\f\e\x95\x84\x86\xA2\xD7b\x9Bp\xD8\xD4\xB9\x88'\xE6\"\x88M~\xC0!:\x8D\xE3\x8Dc%\x96:+\xF1\xC4\xAC\x04\x1A-d\x90\xE1\x13':0Y\x1C+\xB1\xD4Y\x89/f%\x88\tW\x00y\xBBA\x01\\\a4\xDA\xCE\xE2\x98\x8A\xA5\xCET|1S\xC9\xE86\x96w\xCE\x9FQZ'B\x8E\xABX\xEA\\\xC5\x17s\x15\x86\xF0u\x9Amd\xF1a\x96\x8F\x1Et\x1CS\xB1\xD4\x99\x8A/f*\x19-\x1E)-\x14,\xC8\xE4u\xDA\x90\xE3,\x96:g\xF1\xC5\x9C%_\x13\x05B}\x87\xD2:\x11r\x9C\xC5R\xE7,\xBE\x98\xB3\x14\xF4\x8B\xCC\x1C\xFA\x11\xC4\xF4`\xE2\xD8\x8A\xA5\xCEV|1[ao\xBE\x97\x01\x85rzPqL\xC5Rg*\xBE\x98\xA90T\x9F\xB2X\x16X\x99\xC5z\xB0qL\xC5Rg*\xBE\x98\xA9\x94\x89\xD2\xCE\xEE\x13\x13\xD79\xD28\xB6b\xAB\xB3\x15_\xCCV\xD8[L%O\xAF~AY]gW\x80\x87C\xA7\xCE[&b\xDE\xF2\x10\xD1Gi\xFB\xFD\x02\xC2\x1A\xADgs|\xC5V\xE7+\x131_y\x88\xF2h\x1E\xC5pK\xBC\xBB\xFBe/\xABc\x7Fgs\\\xC5V\xE7*\x131Wi\xA1\x13\x18n\x8F\xECZ\x9Bq\x1C\xC5V\xE7(\x131G\xC1\xE7\x93%\a\xDC'\x10\xD57\xDE8fb\xAB3\x93\x89\x98\x99\xC4)\xC1\xDF\xCF\x14\x84.Q\xE6jKq,\xC4Vg!\x131\vi\xF9\xDF\x87\xFD\x8F\xEA\xC8x\xE1\xE1'x\xAEA\xC8q\x12[\x9D\x93L\xC4\x9C\x84\x94a\x04\x85\xC4\x93\xC7\xB3JP\xCB\xCC\xC1\xB1\x12[\x9D\x95L\xC4\xAC\xA4e\xB9g\x98\xA1.g6R\x89^\x83\x8Dc%\xB6:+\x99\x88Y\t\xC3\x16\xD3!\xC6Q$g\xFDZZ\x8B\xF58N\xE2\xA8s\x92\x89\x98\x93DI\xFD\xBA;!\xBA\xB7\xB5\xA4\x0Ed\x0E\xC7G.\xF8\x15\x83@\xCCG\xF6\xC8\xCE\x9F\xC25\xA8\xAE\x9C#\xB9\xDF/\xB0\x1Du\x06\x12\x88\x19HA\xE6o\xA5\xCD\xF5\x91\xCC#\x9D\x16\xE38\x88\xA3\xCEA\x021\ai\xE3;\xBF\xBBia\xBB\xD6n\x1C\vq\xD4YH f!]9\x87}\x0F\vj\xCD9\x04<\x1C:u\x1E\x12\x88yHW\xCE\xE1Yt\xDAX\x96\xC3\xF1\x12G\x9D\x97\x04b^\xD2\x9Ds\xD8\x87Os\xCE!`\xE2\x10\xAA\xF3\x92@\xCCK\xF8\x9C\xC3^dzr\x0E\x01\x03\x87H\x9D\x91\x04bF\xD2\x97s\xD8\x8FMs\xCE!\xE0\xE2P\xAAs\x93@\"\e\xB6+\xE7\xB0\x17\xA2\xD6\x9CC@\xD4\xC67Vg&\x81\x98\x99\x9C\xE4\x1C\xCA`\xBB\xD2nc\x8E\x97\x8C\x95y\t\xBE\xB2@%\xE7\xB0\x0F\x92\x96\x9CC\xE8?\x87F\x99\x93X\xA6\x98\x93\xF4\xE4\x1C\x9E\a\xA6q\xA4\x8D9^2V\xE6%\x96)\xE6%\xBD9\x87}(\xF5\xE7\x1C\x022\x0E\xA72O\xB1L1O9\xCD9\xEC\x03\xA81\xE7\x10\xB0p\xC8\x949\x8A%\xF1\v\xA2\x9D9\x87\xBD\xE0\xB4\xE6\x1C\x02\"\x0E\x9F2K\xB1L1K9\xCE9\xEC\x83\xA6-\xE7\x10pp\xA8\x94\x99\x89e\x8A\x99\xC9Q\xCEa\x1F(m9\x87c\x8E\x9B\x8C\x95\xB9\x89%\xF1\xDB\x9A\xB1\xDC6@[\xCE\xE1\x98c\"ce&bI\xFC\xCEfg\xCEa\x1F2\xCD9\x87c\x8E\x89\xB8\xCAL\xC4\x92\xF8\r\xCE\xCE\x93\xA9^|z\xCF\xA5\\\x8E\x91\xB8\xEA\x8C\xC4\x92\xC889\xCD9\xEC\xFDe\v\x9D9\x87.\xC7O\\u~b\x89\xF9Iw\xCEa?<\xBD9\x87.\xC7N\\uvb\x89\xD9\xC9i\xCEa\xFF\xCF\x92\xE8\xCB9t9>\xE2\xAA\xF3\x11\x89\xDF\xEB<\xCD9\x14\"\xD3\x90s\xE8r|\xC4U\xE7#\x96D&\xECi\xCE\xA1\x18\x9A\x86\x9CC\x97\xE3\"\xAE:\x17\xB1\xE4r`\xE5\a\x9C\xDE\x9CC\x97c%\xAE:+\xB1$2a\xF9\x9C\xC3^d\xBAr\x0E]\x8E\x95\xB8\xEA\xAC\xC4\x92\xC8\x81\xED\xCB9<\x87Ns\xCE!\xF7Ss\xB6\xAB\xCET,1S\xE9\xCE9\xEC\x03\xA9;\xE7\x90{Y\xB5\xED\xA9s\x15K\xCCU\xBAr\x0E\xCF\xE2\xD3\x96s\xE8qL\xC5Sg*\xB6\x98\xA9\xF4\xE5\x1C\xF6#\xD4\x9Ds\xE8q\x9C\xC5S\xE7,\xB6\x98\xB3t\xE7\x1C\xF6a\xD4\x9Ds\xE8q\x9C\xC5S\xE7,\xB6\xC4I\x0F\x9Fs\xD8\aM[\xCE\xA1\xC7\xB1\x15O\x9D\xAD\xD8b\xB6r\x9Cs\xD8\vJ[\xCE\xA1\xC71\x15O\x9D\xA9\xD8b\xA6\xD2\x91sx\x16\x98\xAE\x9CC\x8Fc*\x9E:S\xB1\xC5L\xA5'\xE7\xB0\x0F\x9F\xF6\x9CC\x8Fc+\x9E:[\xB1\xC5l\xA5+\xE7\xB0\x0F\xA0\xDE\x9CC\x8F\xE3-\x9E:o\xB1erO:r\x0E\xFB\xE1i\xCD9\xF48\xBE\xE2\xA9\xF3\x15[\xCCW\xBAr\x0E\xFB\xE1\xE9\xCC9\xF48\xAE\xE2\xABs\x15[&\x1F\x96\xCF9\x94@v\xA5\xCD|\x8E\xA3\xF8\xEA\x1C\xC5\x11s\x94\x8E\x9C\xC3\xDE\x19Eg\xCE\xA1\xCF1\x13_\x9D\x998bf\xD2\xCE9\xEC\x0F]\xEA\xC89\xF49\x16\xE2\xAB\xB3\x10G)\xE7\xB5\x95s(\xE1\x85Zr\x0E}\x8E\x93\xF8\xEA\x9CD\xE2}\xF1'9\x87\xBD\xEF\xA8\xD6\x97s\xE8s\xAC\xC4Wg%\x8E\x98\x95t\xE4\x1CJ\x98\xED\xFA\x9CC\x9Fc%\xBE:+q$3aOr\x0E\xCF\xC2\xD3\x98s\xE8s\x9C\xC4W\xE7$\x8E\x98\x93\x9C\xE6\x1C\xF6\x9EWi\xCC`\xF39>\xE2\xAB\xF3\x11G\xCCG\xF8\x9CC!\xAAk\xE7H\x8E\x81\xF8\xEA\f\xC4\x113\x90\xCE\x9C\xC3\xDE\x1D\x80\xDE\x9CC\x9F\xE3 \x13u\x0E\xE2\x889\xC8I\xCE\xA1\f\xB6+\xED6\xE1X\xC8D\x9D\x85\b\xDFI\x9C\x97\xEC\xA7\x00\xB3\x19\xBEdq\xF6\xB9L\v\xD2\xFB\x92\xC8J\x92\xBD\x8E\xF1\xE2\x17E\x02\b\x1E\x92\xEA\xEF\xB0\xB9\xCE\xD8\x97xU\xA4\xEB\xDA\x81H\xCCA\xB1\xF1D\xCF+%-\xF1k\x8Bi\x12\x82\xA2\xCF\xE9\xF8\r\x13\xB9F\xB9\x01\xA7\\\xD5\x9F&\xB3$4k\xEB\xD2\x97\xE8\xF5\xC4\xB8V\x9FS\xD6\xB3\xFE\x05ZBS\xB6\xD9\xD6\x94\xAD\xFA~vk2\xB4]\x19myC\xE7TN\xA4\xB1\xDBQF\x17i\x16\xE27\xC0Rf\x0Ft7\xFD\x06>\xE5P\xE4\xFF\x00PK\x03\x04\x14\x00\x00\x00\b\x00\x13\xA2\xC6H\xE9{\x1A1\xDD\x06\x00\x001n\x00\x00)\x00\x00\x00temp_146524419820160606-15058-1rdy8ue.dat\xED\x9D]o\xDB6\x14\x86\xEF\xF7+\x88^/\x1E\x0F\xBF\x89]\fm\xB3\x0E\xBD\xD9\nt\xC3zK[t,\xC4\x91<IN\x90\x7F?R\xA2\x18\xC7\x8E34\xC9\xCA\xD4\xD4\t`\xBF\xFA\f\xC9V\xD4\xA3\xA3\x97\fB\x19\x87\xE6\xA9K\xF0?\x86\xA6XpA\xD8\x19\xC5D\x9F\xFD*\x00\xCE\x14\xB8\x0F \xFC\xDD\xF9\xDB\x0F\x1F\xE0\xFC\x03\xA4.c\xAA\x00A\x14Wj\\\xA4@\x180\xC14h\xA5I\xAF\b&b\xDCN\xA5HT\xCE\xF4\xF1~\xD5\xD4W6u)\xBE}p<\xC33\"\x04\xCC\x00\x93\xD4\x85I\x15\x7FU\x97U}S\xC5e\xC0\xE0\xBB\fN)PwY0D\xDDO\b\x8E)\xA3\x0F\x9D\xE4D\xA3\xEC\xD0\x8Di\xD1\xBCn\xCA\xEAb\x86\x8A\xBAk\x7F\x81\x10q'\xFC\xFD*AU\xA8\x87\xE0X\aE\xA4:~\xC4\xB7UR\xE1\xB1|\x98\x1D\xB48\xC7x<\x02F%8\xE1\x8F\xACK^\xA3I\xA5Q\xE4\a\x94q\x10\x9CS\xAF\xEDc!\x8D\xE0`\xAD\xD0\x00\x02xn\xD5\x8F\xE1 X3\xCD\xE2\"\x87\x01\x82)\x06\xD74\x83\xE2\xB1k\xA52[\f\x9A 8_\b\xFE\xBB\xAC\x8A\xFA\xA6E2\xAE\t\x10\f\xC4\x05\x02\a\xC0\x04\xC5\xB6\x91\x9C@\x0E\r\xB5il\xD7\xDD\xA2\xB2\xEA\x1A\xDBv\x0E\x80\x7F\xEC\xF5\xF6\xC2IB\x1C\x01\xBB\x8F\xB8\xF3W\xDE\x94\x95\xD4\x83\x02`81\x9CI\xC0bT\x1CB\xA9\xF4\xCEsNb\x80Q\n\x8FmE\xD4\xFEV\xC04^\xB5\x11x%\xC4\x1E\xFD\xA1u\xC9k4\xA9D*k\bf\xF2\x943\xC1\x0F\x05\xA7\x02\xE6\x04\xEC\x12/ia\x99I]\x9ET\xE1!X\xAA\xD8\xA1\x13\x192\xC1\x94IP\x83\xE2w\xF0C\x15;r\x9E\x93\x8F\xFD\\\xE0\x14\xF9\xC4Q\b&\x9E\x82\xDDW\xFF1n\x93l\x97\xFE2\x8C\xDF\x7FzKB\xC4u_yS\xE6j\xEC\x93\x04S\xFA\xA9gy\x19\xC5\xB5\f\xFF\xF0\xC2!yXG\xE4\x93\xEB\xF6\xD2J\xC4\xF7s\\\xEB\x034g\x9A\x1Fd}\x91\x16\a\x10,\x00'n\xE7I\xA5VYg\x82\x19\x11\xA7\f7\xE7\x84\xD0\xF3\xF7\xEC\xDD\x99`\xE4\xEDd\x87\xB8\x17 \xA8\x12\"v\xE8\xC0]\xC30\xC11'\x04\xD3\xA0x4AP\x99m\xCA|\x82\xE0lcd\xE0/\x9F\xE2\xAA\x1D\b\x06\x87\xBF\xF72\xC1\xC2];\xA7w\x99\\4\xD6thY7\xA8\xAC\xAE\xEB\xF5uY]\xA0\x8D\xAD7k\x8B\xEA%2\xEB5*\xECU}\xD1\x98\xCD\xAA\\\xB4\xBE]\x9E\x93\t\xE6D\r\xEDI\xC8\x1D\xB0\xA5\x82`9\xC2\xBC\xEB\b\x87\xFB$\xEC\xBE=K\f0@4\f\xFD\xB3\xEB\xBC\x89\xD8\xDF\xCA\xB0<\xC8\x04\xD3\xB1u\x1F^\x97\xBAF\x93J\xA5r\x86`\x01$\xB7L\xF0\\`\xBD\xD4\x056\va\xB8\xDEy\b\xCE,@0\xA02V\x1F$x'0\a.\x84\x0EJR\x18/\x15\x01\xEA\xC8yN?>\x9B\xA5i\xCA\xD4\xA5H\x17z\x06\xB3<\x9F\x15\xFF\xF8\x8C\xBE8Z\x98\xEDX\\\x03\x04\xD3!\xDBI\xEFg\x82\x1D\x04\xC3G\xE4\xA0q\xBD\xBEE\xEB\xF2\xD2\x16\xA8[\x95-2\xC5\xCF\xA3\x81v[\x95\xFFlm\xEF\x1F\xB0\xD1L`\xAA\x02]\xDAM\x87\xAEn\x91\xE9:[ue]\xCD\x10\xFA\x18N\xB2\xAAo\xDC\x89\xEC-Z\x19\x7FF\x8B\xDE\\\x97M\xB75\xEB7n\xF7\xD5\xDAv\x16]\x99\xC2\xA2\xED\xC6s\xE9G\xFFK\xABK\xB4X\xD9\xABra\xD6h^WE\xDB\xFF\x92\x95\xB9\xB6hU^\xA1\xCE\\\xDA\xFEL\xED\xCAlz\x9A-\xCA\xE5\xD2\x95\xA8\xEA\xC6S\xB6\xAE\x8C\xA8\xDD\xD4M\xD7\x0E%t\xBBW;ghL\xD5:4\xBE\xF2U\xA9\xFBJ{6\xF6\x19rG\xC1O\xC5W\xD7\xBCx\xE8i(c:5\x04\xEB\xB1\x7F\x148\x80\"\xE5\xFC\xE9Y\xEE\x17V\xAE\xAD\xE8\x80\xBE\x0F\xB5\x15\xA5,\xBA\x97\xEF\xB2\xBE\xF8\x81L0N\xFD\xB01\xA9\xE4*k\bf<7\xB8\x11\xFE\xA9\x9E\xCB\xE5\x1C\x16\xEEG-R\x97'Ux\bv\xC0;.R\xFF*\xD7\xA3\xAFT~\xBCE\xAF4\xD1\#$s\xC8\xF6ia\xCA\x04\xE7\x1CG\x06\xC61J\x81\xF4\x99\xE0\xDD\x81qz\xD7\a\xF0\xFA\xE3\xCFU\xBD\xBDXu#\x9F\x9B\xD1\xEC{Q\xD7\x85CaO\xE1\xC3\x16\a\xB9\x1E\x987u\xE9\x19\xD9\xF1\xF0M\xBD]\x17\x0E\xBC\x1DIGd\xEE\x9A[w\xA6>\r\xFC\f;\xC4+R\x02\x83\xD87\x190\x05\xF8\xD5 \xA3\xE4|\xE8\xBF\x99\xA4\aC\x11\x99 z?\xEB+0\x86\x98\xF4\x82\x98\xE5f\xC7\xED\x10\x9C\xB1\xE0\x81\xE6L\xABWS\xF3I\xBD\xAC\xCA\xDA\x0E!Tv^\xCF\xC5\x82(\xB6\x00f\x157\x82Z\xF9\xDFG\x9Cf8\b\x16\xFCn\x90\x87\xBB\xA9\xF7v\bB\xB0\xE3\xE0\xA08\x8D\x9E`\x9E\xDB\xFF\x93\x18\x13\x04\xE7\x1CG 8\xF8^\xC9\xFD\x81q\xF8\xFB\x82\xE0\b\xB9\x9Ezg!\xEF<\xA6\x9D\xD1M\xD9\xD8ec\xAE\x1C\xDF\xCE\xED\xC2}\xC7l\xAFwB\x98\xAE\xDF\xC9V\xEE\xC0O\x03;/\xEAz=\x03xV&\x18\t\x1A\x06\xA3\xF9\x8E(\xF1<\f\\\xD1P\x02.\xF5\xA0\b\xEC`dj\x80\x91\xE3\xFC\x0F\x04(\xDD\xC7u\x82)9\xC8\xFAr!\xF0#\xEB\x92\xD7hRiT\xD6\x10,\xB1>=\x13\xDB\xE31\xD7Km\x940\x05\xC8\xB9Tt\x9E\xBA<\xA9\xC2A\xB0\xEA\xA7y\x1A\"L\x91\xE6\xD0W\x92\x11\x82\xA5\xA6c\xA6Xd\xF7\xC6 \xC6\x04\xC19\xC7#\x10\f\xFD\xB0|\xF71nS\x8A@R\xDF\xC8\x9E\x15\xC3\xE3l\xD9\xA1\xD6}\x87\xA5\xDFLW7\xDE8\x11\xF6[\x98\xC61\xAE\x99\xD7\xDB\x81i\x03\xE1\xDE\xACj\xB4m\xAD?\xB87Q\x8Cn\x8Cp\x94\xCF\xF9v\xF5\x90\b.\x83]\xB8k\xFD\x11\xCD\xE8\t>\xD9L\xF0\xBDY\xF0\xD2\x96O\x12\x86\x87\x1C\x0Ee\xFC`p\e\xA5J\xEC\xDB!\xB8f\xD1\xE0\xF6\xD0\xBA\xD45\x9AT\"\x957\x04S\xFE}\xA5.\x9E\x1F\x9ChU\x14Ba,\v\xCED\xCE\x99`\xCDi\xBCg\x13N\xFA\xE1p\x84\x12\xE0:(\xA6\xE3<\xC14[;\xC44EZ\xBES\xA4\x1D\x85`\xCFy\xDC\xE1\xAF_\x88\xD7\x90\xD6\x90\x16\x82\x13FU.,2E\xFB\xFC\xD9!\xC6\x89\xD1\xA4\xA0\x89\x87\xA0\x898'\x8E`\xE3\x00r\xAE\xF9\xAB\x01|)Fk\x06W\xFA k\xCE\xD4\xE1th\x82\x91C\x9F\xF0\xDD\xBA\xE45\x9AT\x1A\x05YC\xB0\xDEy\x15\x92G\xC8\xA5QDh(xA\xD8|\x9E\xED\xDD\x1D\x1C\xE6b\x1C\x9F\x01@\a;\x04\xA3J\x0E9a\xC6 \xBE'\xA0\x93'x\x8A\xFC\xE2\xF8\x14i\xDE\xF9\xBA?O\xB0\x92\xA7:EZpJ\x94\x1D\xBA\xB6\xDE\xFA[\xB5\x9B\xD2\xFF\x85\x8C>Ql\x16~\x1C\x1F\xDA\x98\xC5\xA5- L\x14\x1C\x0F\xFDZ\b&ab/\xC02u\x86\x92\xCBh\x19P2(\xFD\x8A<\xC1\"\x96\xCF\xFF\x89\xA3\xFD\xAD\x8A\xF0\xB1\xCF\xBE\xB3>H\x86\x1FY\x97\xBCF\x93J\xA3\xE0_PK\x01\x024\x03\x14\x00\x00\x00\b\x00\x13\xA2\xC6H]\x15\x85\xBCb\x17\x00\x00\xD3\xA8\x00\x00)\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x80\x81\x00\x00\x00\x00temp_146524419720160606-15058-1085bsl.xmlPK\x01\x024\x03\x14\x00\x00\x00\b\x00\x13\xA2\xC6H\xE9{\x1A1\xDD\x06\x00\x001n\x00\x00)\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x80\x81\xA9\x17\x00\x00temp_146524419820160606-15058-1rdy8ue.datPK\x05\x06\x00\x00\x00\x00\x02\x00\x02\x00\xAE\x00\x00\x00\xCD\x1E\x00\x00\x00\x00", "survey_name"=>"Gatorade SFR - Your Game is Our Lab 1:11", "client_name"=>"Georgios Skouras", "survey_type"=>"link_now_digital", "project_name"=>"Gatorade SFR - Your Game is Our Lab 1:11", "primary_contact_email"=>"georgios.skouras@millwardbrown.com", "category"=>"Sports Drinks"}
PP.pp a
a.delete(:file_data)
PP.pp a
a.delete!(:file_data)
a.delete('file_data')
PP.pp a
exit
Survey
SurveyRepository
Repositories::SurveyRepository
Repositories::SurveyRepository.all_not_sent
Repositories::SurveyRepository.new.all_not_sent
repo = Repositories::SurveyRepository.new
repo.find_by_blueprint
repo.find(1)
surv = _
surv.blueprint
surv = repo.find(7747)
surv.blueprint
surv.blueprint.label
surv.blueprint.label.to_s
exit
survey.blueprint.label
survey.blueprint
survey.bluprint = bluepritn
survey.bluprint = blueprint
survey.blueprint
exit
survey.blueprint ? survey.blueprint.label.to_s : survey.product_code
exit
Repositories::SurveyRepository
Repositories::SurveyRepository.all
Repositories::Backends::Database::SurveyBackend
Repositories::Backends::Database::SurveyBackend.all
Repositories::Backends::Database::SurveyBackend.new.all
Repositories::Backends::Database::SurveyBackend.new.all.map(&:product_code)
res = _
res.uniq
uniq_res = _
surveys = _
Repositories::Backends::Database::SurveyBlueprintBackend
Repositories::Backends::Database::SurveyBlueprintBackend.new.all.map(&:label)
blueprints = _.uniq
survey - blueprints
surveys - blueprints
blueprints_2 = blueprints.map { |e| e.to_s }
surveys - blueprints_2
blueprints_2 = surveys
blueprints_2 = blueprints.map { |e| e.to_s }
blueprints_2 - surveys
exit
Repositories::Backends::Database::SurveyBlueprintBackend.new.find_by(label: :link_now_for_gatorade
)
Repositories::Backends::Database::SurveyBlueprintBackend.new.find_by(label: :link_now_for_gatorade)
DatabaseModels
DatabaseModels::SurveyBlueprint
DatabaseModels::SurveyBlueprint.find_by(label: :link_now_for_gatorade)
DatabaseModels::SurveyBlueprint.find_by(code: :link_now_for_gatorade)
DatabaseModels::SurveyBlueprint.first
DatabaseModels::SurveyBlueprint.all.map(&:survey_label)
DatabaseModels::SurveyBlueprint.all.map(&:survey_label).uniq
DatabaseModels::SurveyBlueprint.find_by(survey_label: "link_now_digital_gatorade")
DatabaseModels::SurveyBlueprint.find_by(survey_label: "link_now_digital_gatorade").id
exit
90 + 72 + 72 + 72 + 54
false.nil?
false.blank?
Order.last
order = Order.last
order.demographics
order.demographics.class
order.demographics.panel_size
Order.find(208940)
order = _
order.processing_result
order.demographics
order.demographics.panel_siz
order.demographics.panel_sizd
order.demographics.panel_size
order.demographics.method(:panel_size).source_location
string = "a"
Digest::SHA1.hexdigest(string.to_s)
_.length
Digest::SHA1.hexdigest("denesh is cool").length
"how_would_you_describe_your_involvement_in_purchase_decisions_for_internet_and_tv_services_in_your_ho_0dbf857dcacb548264a8cd9c94076122c95233cb".length
"0dbf857dcacb548264a8cd9c94076122c95233cb".length
exit
CheckoutSystemModels::OrderDetails
CheckoutSystemModels::OrderDetails.find({})
CheckoutSystemModels::OrderDetails.all
exit
Order.last
params
next
step
params
next
params
next
params
next
params
next
params
current_product_target.attributes
current_product_configuration
PP.pp current_product_configuration
current_product_configuration.inspect
current_product_configuration.advanced_analysis_elements_count
response_data
caller
caller.reject{ |x| x.include?('gem') }
up
order_id
response
up
ordeR_id
order_id
retrieve_order_responses_request(order_id)
retrieve_order_responses_request(order_id).response
response_data
exit!
ProductConfigurationForm.parse(params, current_customer).product_configuration_params
params
ActiveRecode
ActiveRecord
ActiveRecord::Base.connection
connection = _
connection.execute('select zap_fsp.project_id, dc.respondent_id, dc.available_languages from zappistore_development.panel_providers_federated_sample_projects as zap_fsp inner join ( select sr.survey_id, sr.respondent_id, replace(s.available_languages, '\n', '') as available_languages from datacollector_development.survey_responses sr inner join ( select id, available_languages from datacollector_development.surveys where quotas like '%Fulcrum%') as s on s.id = sr.survey_id and sr.region is null where sr.respondent_id regexp '^[0-9]*$') as dc on zap_fsp.survey_id = dc.survey_id;')
connection.execute("select zap_fsp.project_id, dc.respondent_id, dc.available_languages from zappistore_development.panel_providers_federated_sample_projects as zap_fsp inner join ( select sr.survey_id, sr.respondent_id, replace(s.available_languages, '\n', '') as available_languages from datacollector_development.survey_responses sr inner join ( select id, available_languages from datacollector_development.surveys where quotas like '%Fulcrum%') as s on s.id = sr.survey_id and sr.region is null where sr.respondent_id regexp '^[0-9]*$') as dc on zap_fsp.survey_id = dc.survey_id;")
result = _
result.first
result.class
result.first.class
PanelProviders::Models::FederatedSample
PanelProviders::Models::FederatedSample::Project
PanelProviders::Models::FederatedSample::Project.all
PanelProviders::FederatedSample::Project
PanelProviders::FederatedSample::Project.all
PanelProviders::FederatedSample::Project.last
exit
"RubyProf::#{ measure_mode }"
"RubyProf::#{ params[:measure_mode] }"
params
next
RubyProf.measure_mode
measure_mode
CheckoutSystemModels::AttributeOptions::AdNowOptions.new.media_exposure_options.find
CheckoutSystemModels::AttributeOptions::AdNowOptions.new.media_exposure_options.find.map { |x| x }
exit
@form
@form.class
@form.method(:get_raw_options)
@form.method(:get_raw_options).source_location
@form.attribute_options
@form.get_raw_options(:media_exposure_options)
exit
Repositories::SurveyBlueprintRepository
Repositories::SurveyBlueprintRepository.all
Repositories::SurveyBlueprintRepository.new.all
exit
translation.lang_code
cache.find(translation.lang_code, "action_GB_en_6_")
cache = Services::TranslationCache.new
cache.find(translation.lang_code, "action_GB_en_6_")
cache.fetch(translation.lang_code, "action_GB_en_6_")
cache.fetch(translation.lang_code, "action_GB_en_6_") do "hi" end
TranslationCache
finder = TranslationFinder.new("FR_fr")
finder.find("FR_fr:regional_press_questions_newspaper_titles_read_answer_options_OUFR") { "fuck" }
finder.find("regional_press_questions_newspaper_titles_read_answer_options_OUFR")
exit
[Presenters::Variable.new(
    question.id,
    question.label,
    variable_type,
    decorated_question.content,
    values,
    variable_options,
    question.response_constraints
)]
next
Presenters::VariableBuilders::Questions::AdNowMediaExposureBuiler
Presenters::VariableBuilders::Questions::AdNowMediaExposureBuilder
builder = Presenters::VariableBuilders::Questions::AdNowMediaExposureBuilder
bui = builder.new(survey, question)
built = bui.build
res = _
res.include_id?
res.class
res.first
res = res.first
res.class
res.include_id?
res.id_label
question.send(res.id_label0
)
question.send(res.id_label)
question
survey.configuration_data
survey.configuration_data["media_exposure"]
question
question.answer_options
res
res.values
next
[Presenters::Variable.new(
    question.id,
    question.label,
    variable_type,
    decorated_question.content,
    values,
    variable_options,
    question.response_constraints
)]
res = _[0]
res.values
res.values.first.class
decorated_question.answer_options.first
self
survey
question
decorated_question
decorated_question.answer_options
decorated_question.answer_options.map(&:label)
question.answer_options
question.answer_options.map(&:label)
survey.configuration_data["media_exposure"]
survey.configuration_data["media_exposure"].select{ |option| option["answer_text"] == :catchup_tv.to_s ]
survey.configuration_data["media_exposure"].select{ |option| option["answer_text"] == :catchup_tv.to_s }
survey.configuration_data["media_exposure"].select{ |option| option["answer_text"] == :catchup_tv.to_s }.id
survey.configuration_data["media_exposure"].select{ |option| option["answer_text"] == :catchup_tv.to_s }.try("answer_id")
survey.configuration_data["media_exposure"].select{ |option| option["answer_text"] == :catchup_tv.to_s }.try(:answer_id)
survey.configuration_data["media_exposure"].find{ |option| option["answer_text"] == :catchup_tv.to_s }
survey.configuration_data["media_exposure"].find{ |option| option["answer_text"] == :catchup_tv.to_s }.try(:answer_id)
survey.configuration_data["media_exposure"].find{ |option| option["answer_text"] == :catchup_tv.to_s }.try("answer_id")
survey.configuration_data["media_exposure"].find{ |option| option["answer_text"] == :catchup_tv.to_s }["fuck u"]
survey.configuration_data["media_exposure"].find{ |option| option["answer_text"] == :catchup_tv.to_s }["answer_id"]
config_data
config_data["media_exposure"]
option.label
id, code, content
config_data["media_exposure"].find{ |exp| exp["answer_text"] == option.label.to_s }
config_data["media_exposure"].find{ |exp| exp["answer_text"] == option.label.to_s }["answer_id"]
val
variables
variables[16]
variables[16].values
value
value.xml_options
value
variable
variable.values.each_with_index do |value, answer_index|
  xml.value(value_content(value.content, answer_index), value.xml_options)
end
context.configuration[:survey_component]
exit
configuration_value
caller.reject{ |x| x.include?('gem') }
group_source
group_source.present?
configuration_value.with_indifferent_access[label_source]
configuration_value.with_indifferent_access[label_source].to_sym
question
question.sources
question.class
ACCEPTED_ANSWER_OPTION_IDS
ACCEPTED_ANSWER_OPTION_IDS[option.label]
option.label
ACCEPTED_ANSWER_OPTION_IDS[option.label]
additional_options
context
context.answer_options
opts
context
context.class
context.configuration
context.configuration.send(:entries)
context.configuration[media_exposure]
context.configuration[:media_exposure]
context.questions
opts
self
next
additional_options[:export_ids]
options
self
options
self
export_ids
self.export_ids
self.class
answer_options_export_ids
options
question.label
question.class
question.try(:answer_options_export_ids)
Generators::Question::MultipleChoice
Generators::Question::MultipleChoice.new
Generators::Question::MultipleChoice.new({ text: "fuck u" })
Generators::Question::MultipleChoice.new({ text: "fuck u", id: 666 })
Generators::Question::MultipleChoice.new({ text: "fuck u", id: 666, label: "fuck_u" })
res = _
res.generate
res.answer_options
exit
generated_question
subject.generate(context)
generated_question
::Question::MultipleChoice.new(
  id,
  label,
  generate_content,
  generate_answer_options(context),
  generate_options(context)
)
res = _
res.answer_options_export_ids
a = nil
a = "lol"
exit
@answer_options_export_ids
additional_options[:export_label]
@answer_options_export_labep
@answer_options_export_labe;
@answer_options_export_label
@answer_options_export_ids
answer_options_export_label
answer_options_export_ids
@answer_options_export_label
@answer_options_export_ids
@answer_options_export_label
@answer_options_export_ids
@answer_options_export_label
@answer_options_export_ids
attrs
opts
page.html
page
next
CheckoutSystem::OrderProcessing::Pipelines::OrderPipelineFactory.build_pipeline(order).execute
Order.last
order = Order.last
CheckoutSystem::OrderProcessing::Pipelines::OrderPipelineFactory.build_pipeline(order).execute
exit
translation.key
exit
cache_key
Rails.cache.read("*#{ cache_key }*")
Rails.cache.read("*FR_fr:#{ cache_key }")
translation.key
extractor.first
extractor.first[1]
extractor.first[1].first
extractor.first[1].first.keys
finder
Rails.cache.find("FR_fr:ad_now_questions_link_services_brand_usage_answer_options_heard_but_never_used")
Rails.cache.fetch("FR_fr:ad_now_questions_link_services_brand_usage_answer_options_heard_but_never_used")
Rails.cache.delete_matched("*ad_now_questions_link_services_brand_usage_answer_options_heard_but_never_used*")
Rails.cache.find("FR_fr:action_fr_fr_1_1")
Rails.cache.fetch("FR_fr:action_fr_fr_1_1")
"FR_fr:action_fr_fr_2_1".to_upper
"FR_fr:action_fr_fr_2_1".uppercase
"FR_fr:action_fr_fr_2_1".lowercase
"FR_fr:action_fr_fr_2_1".capitalize
"FR_fr:action_fr_fr_2_1".upcase
"FR_fr:action_fr_fr_2_1".downcase
Rails.cache.fetch("FR_fr:ad_now_title")
Rails.cache.fetch("FR_fr:ad_now_questions_link_affinity_scale_58")
Rails.cache.send("FR_fr", "ad_now_questions_link_affinity_scale_58")
finder = TranslationFinder.new("FR_fr")
finder.send(:find_uncached, "ad_now_questions_link_affinity_scale_58")
exit
next
ordered_media_exposures(ids).map do |media_exposure_option|
  {
    group_name: media_exposure_option[:group],
    answer_text: media_exposure_option[:name],
    answer_id: media_exposure_option[:id]
  }
end
up
exit!
caller.reject{ |x| x.include?('gem') }
::OrderDataAdapters::Models::AdNowProductConfiguration.new(
  {
    product_category_id: section_data["category_type"],
    media_exposure: adapt_media_exposure(section_data["media_exposure_ids"]),
    language_code: section_data["language_code"]
  }.with_indifferent_access
)
exit!
order_model.class
exit!
order_model.attributes
exit!
order_model.attributes
exit!
order = Order.last
CheckoutSystem::OrderProcessing::Pipelines::OrderPipelineFactory.build_pipeline(order).execute
configuration_xml
key
value
key
value
exit
value
value == true
type
value
type
value
Surveys.last
Repositories::SurveyRepository.new
Repositories::SurveyRepository.new.last
sr = Repositories::SurveyRepository.new
sr.find(8123)
surv = _
surv.blueprint
surv.blueprint_id
surv.blueprint_id = 77
surv.save
surv.save!
surv.update!
surv.save!
sr.update(surv)
surv = sr.find(8123)
surv.blueprint_id = 78
sr.update(surv)
(1000..2000).to_enum
gen = _
gen.next
"hi #{ nil }"
exit
ActiveRecord::Base.connection
con = _
sql = 'select common_schema.extract_json_value(zap_fsp.project_creation_data, '/id') as surv_id, dc.respondent_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
) as dc
on zap_fsp.survey_id = dc.survey_id 
'
sql = "select zap_fsp.project_creation_data, dc.respondent_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
) as dc
on zap_fsp.survey_id = dc.survey_id 
"
conn.execute(sql)
con.execute(sql)
require "pry"
con.execute(sql) { |row| binding.pry }
row
exit!
sql = "select zap_fsp.project_creation_data, dc.respondent_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
) as dc
on zap_fsp.survey_id = dc.survey_id 
"
result = ActiveRecord::Base.connection.execute(sql).first
require "csv"
result = ActiveRecord::Base.connection.execute(sql)
result.first
result.first[0]
JSON.parse(result.first[0])
JSON.parse(result.first[0])["id"]
result.each { |row| CSV.open('tmp/regions_missing.csv', "w+") { |csv| csv << [JSON.parse(row[0])["id"], row[1]] } }
JSON.parse(result.first[0])["id"]
result.map { |row| [JSON.parse(row[0])["id"], row[1]]  }
result.take(10)
result.take(10).each
result.take(10).each { |row| JSON.parse(row[0])["id"] }
result.take(10).map { |row| row[0] }
result.take(10).map { |row| row[1] }
result.take(10).map { |row| row[0] }
result.take(10).map { |row| JSON.parst(row[0])["id"] }
result.take(10).map { |row| JSON.parse(row[0])["id"] }
result.map { |row| JSON.parse(row[0])["id"] }
begin
  result.map { |row| JSON.parse(row[0])["id"] }
rescue
begin
riq = nil
begin
  result.map { |row| riq = row; JSON.parse(row[0])["id"] }
rescue
  puts riq
end
result.each { |row| CSV.open('tmp/regions_missing.csv', "w+") { |csv| begin csv << [JSON.parse(row[0])["id"], row[1]] rescue end  } }
result.each { |row| CSV.open('tmp/regions_missing.csv', "w+") { |csv| csv << [JSON.parse(row[0])["id"], row[1]] } }
result.each { |row| CSV.open('tmp/regions_missing.csv', "w+") { |csv|
    begin
      csv << [JSON.parse(row[0])["id"], row[1]]
    rescue
    end
  }
}
result.each { |row| CSV.open('tmp/regions_missing.csv', "w+") { |csv|
    begin
      csv << [JSON.parse(row[0])["id"], row[1]]
    rescue
    end
  }
}
result.count
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp.regions_missing.csv", "w+") do |csv|
    begin
      csv << [JSON.parse(row[0])["id"], row[1]]
    rescue
    end
  end
end
result.each do |row|
  CSV.open("tmp.regions_missing.csv", "w+") do |csv|
    begin
      csv << [JSON.parse(row[0])["id"], row[1]]
    rescue
      csv << ["Error", row[0]]
    end
  end
end
result.each do |row|
  CSV.open("tmp.regions_missing.csv", "wb") do |csv|
    begin
      csv << [JSON.parse(row[0])["id"], row[1]]
    rescue
      csv << ["Error", row[0]]
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing_2.csv", "wb") do |csv|
    begin
      csv << [JSON.parse(row[0])["id"], row[1]]
    rescue
      csv << ["Error", row[0]]
    end
  end
end
result.each do |row|
  CSV.generate do |csv|
    begin
      csv << [JSON.parse(row[0])["id"], row[1]]
    rescue
      csv << ["Error", row[0]]
    end
  end
end
result.each do |row|
  puts row[0]
  CSV.generate do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]]
  end
end
result.each do |row|
  puts JSON.parse(row[0])["id"]
  CSV.generate do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]]
  end
end
last = ""
result.each do |row|
  last = row[0]
  puts JSON.parse(row[0])["id"]
  CSV.generate do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]]
  end
end
last
last = ""
result.each do |row|
  last = row[0]
  puts JSON.parse(row[0])["id"]
  CSV.generate do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]] if last
  end
end
last = ""
result.each do |row|
  last = row[0]
  puts JSON.parse(row[0])["id"] if last
  CSV.generate do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]] if last
  end
end
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing_2.csv", "wb") do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]] if row[0]
  end
end
result = ActiveRecord::Base.connection.execute(sql)
sql = "select zap_fsp.project_creation_data, dc.respondent_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
) as dc
on zap_fsp.survey_id = dc.survey_id 
"
result = ActiveRecord::Base.connection.execute(sql)
exit
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing_2.csv", "wb") do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]] if row[0]
  end
end
sql = "select zap_fsp.project_creation_data, dc.respondent_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
) as dc
on zap_fsp.survey_id = dc.survey_id 
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing_2.csv", "wb") do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]] if row[0]
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "wa") do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]] if row[0]
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    csv << [JSON.parse(row[0])["id"], row[1]] if row[0]
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      csv << [json["id"], json["name"], row[1]]
    end
  end
end
sql = "select zap_fsp.project_creation_data, dc.respondent_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id, sr.region
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
  where region is null
) as dc
on zap_fsp.survey_id = dc.survey_id 
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      csv << [json["id"], json["name"], row[1]]
    end
  end
end
sql = "select zap_fsp.project_creation_data, dc.respondent_id, dc.survey_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id, sr.region
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
  where region is null
) as dc
on zap_fsp.survey_id = dc.survey_id 
into outfile '/Users/deneshshan/tmp/csv/num_reg_miss.csv'
fields terminated by ',';
sql = "select zap_fsp.project_creation_data, dc.respondent_id, dc.survey_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id, sr.region
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
  where region is null
) as dc
on zap_fsp.survey_id = dc.survey_id 
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      csv << [json["id"], json["name"], row[1], row[2]]
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      raise unless /[0-9]*/.match(id)
      csv << [, json["name"], row[1]]
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      raise unless /[0-9]*/.match(id)
      csv << [id, json["name"], row[1]]
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      raise "type = #{ id.class }" unless id.is_a?(Fixnum) 
      csv << [id, json["name"], row[1]]
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      if id.is_a?(Fixmnum)
        csv << [id, json["name"], row[1]]
      end
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      if id.is_a?(Fixnum)
        csv << [id, json["name"], row[1]]
      end
    end
  end
end
sql = "select zap_fsp.project_creation_data, dc.respondent_id 
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id, sr.region
  from datacollector_development.survey_responses sr
  inner join
  (
    select distinct survey_id, count(survey_id) as num_responses
    from datacollector_development.survey_responses
    where region is null
    group by survey_id
    having num_responses >100
  ) as sr_num
  on sr_num.survey_id = sr.survey_id
  where region is null
) as dc
on zap_fsp.survey_id = dc.survey_id 
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      puts id.class
      if id.is_a?(Fixnum)
        csv << [id, json["name"], row[1]]
      end
    end
  end
end
/[0-9]*/.match("123563253")
/[0-9]*/.match("123563253s")
/[0-9]*/.match("123563253sq")
/^[0-9]*$/.match("123563253sq")
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = ro[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id]
      end
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id]
      end
    end
  end
end
sql = "select zap_fsp.project_creation_data, dc.respondent_id 
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id, sr.region
  from datacollector_development.survey_responses sr
  where sr.region is null
) as dc
on zap_fsp.survey_id = dc.survey_id 
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id]
      end
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id]
      end
    end
  end
end
sql = "select zap_fsp.project_creation_data, dc.respondent_id, dc.survey_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id, sr.region
  from datacollector_development.survey_responses sr
  where sr.region is null
) as dc
on zap_fsp.survey_id = dc.survey_id
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id]
      end
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id, row[2]]
      end
    end
  end
end
sql = "select zap_fsp.project_creation_data, dc.respondent_id, zap_surv.survey_id
from zappistore_development.panel_providers_federated_sample_projects zap_fsp inner join
(
  select sr.survey_id, sr.respondent_id, sr.region
  from datacollector_development.survey_responses sr
  where sr.region is null
) as dc
on zap_surv.survey_id = dc.survey_id
inner join zappistore_development.surveys as zap_surv
on zap_surv.id = zap_fsp.survey_id
"
result = ActiveRecord::Base.connection.execute(sql)
sql = "select fsp.project_creation_data, fsp_id_resp_id.respondent_id, fsp_id_resp_id.survey_id
from zappistore_development.panel_providers_federated_sample_projects as fsp
inner join
(
  select zap_surv.id, dc.survey_id, dc.respondent_id 
  from zappistore_development.surveys as zap_surv 
  inner join
  (
    select sr.survey_id, sr.respondent_id, sr.region
    from datacollector_development.survey_responses sr
    where sr.region is null
  ) as dc
  on zap_surv.survey_id = dc.survey_id
) as fsp_id_resp_id 
on fsp.survey_id = fsp_id_resp_id.id
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id, row[2]]
      end
    end
  end
end
sql = "select fsp.project_creation_data, fsp_id_resp_id.respondent_id
from zappistore_development.panel_providers_federated_sample_projects as fsp
inner join
(
  select zap_surv.id, dc.survey_id, dc.respondent_id 
  from zappistore_development.surveys as zap_surv 
  inner join
  (
    select sr.survey_id, sr.respondent_id, sr.region
    from datacollector_development.survey_responses sr
    where sr.region is null
  ) as dc
  on zap_surv.survey_id = dc.survey_id
) as fsp_id_resp_id 
on fsp.survey_id = fsp_id_resp_id.id
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing_2.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id]
      end
    end
  end
end
exit
sql = "select fsp.project_creation_data, fsp_id_resp_id.respondent_id
from zappistore_development.panel_providers_federated_sample_projects as fsp
inner join
(
  select zap_surv.id, dc.survey_id, dc.respondent_id 
  from zappistore_development.surveys as zap_surv 
  inner join
  (
    select sr.survey_id, sr.respondent_id, sr.region
    from datacollector_development.survey_responses sr
    where sr.region is null
  ) as dc
  on zap_surv.survey_id = dc.survey_id
) as fsp_id_resp_id 
on fsp.survey_id = fsp_id_resp_id.id
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        # csv << [id, json["name"], resp_id]
        csv << [id, resp_id]
      end
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id]
        # csv << [id, resp_id]
      end
    end
  end
end
sql = "select fsp.project_creation_data, fsp_id_resp_id.respondent_id
from zappistore_development.panel_providers_federated_sample_projects as fsp
inner join
(
  select zap_surv.id, dc.survey_id, dc.respondent_id 
  from zappistore_development.surveys as zap_surv 
  inner join
  (
    select sr.survey_id, sr.respondent_id, sr.region
    from datacollector_development.survey_responses sr
    where sr.region is null
  ) as dc
  on zap_surv.survey_id = dc.survey_id
) as fsp_id_resp_id 
on fsp.survey_id = fsp_id_resp_id.id
"
result = ActiveRecord::Base.connection.execute(sql)
result.each do |row|
  CSV.open("tmp/regions_missing_2.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        csv << [id, json["name"], resp_id]
        # csv << [id, resp_id]
      end
    end
  end
end
result.each do |row|
  CSV.open("tmp/regions_missing.csv", "a") do |csv|
    if row[0]
      json = JSON.parse(row[0])
      id = json["id"]
      resp_id = row[1]
      if /^[0-9]*$/.match(resp_id)
        # csv << [id, json["name"], resp_id]
        csv << [id, resp_id]
      end
    end
  end
end
exit
EyeSquareConnector::Client.new(logger: ::ConnectionLogger::ExternalHandlers::EyeSquareHandler.new)
client = _
client.create_projec
client.create_project
client.create_project(1,2,3)
client = EyeSquareConnector::Client.new(logger: ::ConnectionLogger::ExternalHandlers::EyeSquareHandler.new)
client.create_project(1,2,3)
EyeSquareConnector
url = "http://apps.eye-square.com/api/v2/config/projects"
request = "{"client":"millward_brown Chile LinkNow for Digital 2016-08-02 #12923 209446","task":{"taskDuration":90000,"language":"es-CL"},"ads":[{"id":"76fefcda-22e4-4ec1-8b40-ccf43102ad4d","context":"youtube","contextMode":"public","type":"youtube-preroll-skipable","device":"desktop","data":{"brandName":"Ripley","videoName":"Ripley -DÃ­a del NiÃ±o","channelName":"Ripley","logoSrc":"https://s3.amazonaws.com/com.intellectionsoftware.zappi.video.in/production/media_files/89fb824b24632f35ced9f9505d0be81089bd59df.png","mediaSrc":"https://s3.amazonaws.com/com.intellectionsoftware.zappi.video.out/production/transcoded_media_files/5cb7dc2264976853254e90e58bda1a9573a43550/eyesquare_video.webm"},"taskSequence":"task","userGuidance":false}]}
request = '{"client":"millward_brown Chile LinkNow for Digital 2016-08-02 #12923 209446","task":{"taskDuration":90000,"language":"es-CL"},"ads":[{"id":"76fefcda-22e4-4ec1-8b40-ccf43102ad4d","context":"youtube","contextMode":"public","type":"youtube-preroll-skipable","device":"desktop","data":{"brandName":"Ripley","videoName":"Ripley -DÃ­a del NiÃ±o","channelName":"Ripley","logoSrc":"https://s3.amazonaws.com/com.intellectionsoftware.zappi.video.in/production/media_files/89fb824b24632f35ced9f9505d0be81089bd59df.png","mediaSrc":"https://s3.amazonaws.com/com.intellectionsoftware.zappi.video.out/production/transcoded_media_files/5cb7dc2264976853254e90e58bda1a9573a43550/eyesquare_video.webm"},"taskSequence":"task","userGuidance":false}]}'
EyeSquareConnector::Requests::CreateProject(url, request, :POST)
EyeSquareConnector::Requests
EyeSquareConnector::Requests::CreateProject
EyeSquareConnector::Requests::CreateProject.method(:call)
EyeSquareConnector::Requests::CreateProject.method(:response)
conn = EyeSquareConnector::Requests::CreateProject.new({})
conn = EyeSquareConnector::Requests::CreateProject.new({ client_name: 'lol', task_options: {}, ad_options_list: {} })
conn.call(url, request, :POST)
resp = _
resp.to_yaml
File.open('tmp/eyes_resp.yml', 'w+') { |f| f.write(resp.to_yaml) }
exit
CheckoutSystemModels::ProductConfigurations::LinkNowDigitalConfiguration
CheckoutSystemModels::ProductConfigurations::LinkNowDigitalConfiguration.last
last_conf = _
last_conf.try(:language_code)
CheckoutSystemModels::ProductConfigurations::LinkNowDigitalConfiguration.all
CheckoutSystemModels::ProductConfigurations::LinkNowDigitalConfiguration.count
CheckoutSystemModels::ProductConfigurations::LinkNowDigitalConfiguration.first
CheckoutSystemModels::ProductConfigurations::LinkNowDigitalConfiguration.first.language_code
jk
EyeSquareConnector::Config.config[:user_guidance_aviability_by_language_code].include?(product_configuration_language_code)
EyeSquareConnector::Config.config[:user_guidance_aviability_by_language_code]
product_configuration_language_code
EyeSquareConnector::Config.config[:user_guidance_aviability_by_language_code].include?(product_configuration_language_code)
EyeSquareConnector::Config.config[:user_guidance_aviability_by_language_code]
EyeSquareConnector::Config.config[:user_guidance_aviability_by_language_code] = ["en", "sv"]
EyeSquareConnector::Config.config[:user_guidance_aviability_by_language_code]
EyeSquareConnector::Config.config[:user_guidance_aviability_by_language_code].include?(product_configuration_language_code)
sr = Repositories::SurveyRepository.new
sr.last
surv = _
surv.blueprint
surv.blueprint_id
surv.blueprint_id = 65
sr.update(surv)
surv.blueprint_id = 85
sr.update(surv)
exit
exit
require "github_api
"
require "github_api"
Github
exit
Github
github = Github.new(basic_auth: 'denesh.shan@outlook.com:ch33s3burg3r', adapter: :typheous, user: 'Intellection', repo: 'zappistore.app')
github.repos.releases.list
github.repos
exit
sr = Repositories::SurveyRepository.new
surv = sr.find(8649)
survey = survey_repository.find(survey_id)
survey = surv
generator = Services::DummyResponsesGenerator.new(survey)
generator.send(generate_question_responses(
generator.send(generate_question_responses)
generator.send(:generate_question_responses)
q
suevey
survey
survey.questionnaire
survey.questionnaire.flatten
survey.blueprint_id
survey.title
survey = sr.find(8626)
survey.title
survey.questionaire
survey.questionnaire
survey.questionnaire.flatten
generator = Services::DummyResponsesGenerator.new(survey)
generator.send(:questions_with_constraints)
generator.send(:questions_with_constraints)[0]
generator.send(:questions_with_constraints)[1]
generator.send(:questions_with_constraints).values[0]
const = _
const.inspect
generator.send(:questions_with_constraints).values[1]
generator.send(:questions_with_constraints).values[]
generator.send(:questions_with_constraints).values[2]
generator.send(:generate_question_responses)
survey = sr.last
generator = Services::DummyResponsesGenerator.new(survey)
generator.send(:questions_with_constraints)
qwc = _
qwc.keys.first
qwc.keys.first.inspect
qwc.keys.first.class
qwc.values.first
qwc.values.first.class
qwc.keys.first.responses
qwc.keys.first.ancestors
qwc.keys.first.class.ancestors
generator.send(:generate_question_responses)
context.configuration
context.configuration[:survey_component]
context.configuration[:survey_component][@source]
exit
context.configuration[:survey_component][@source]
exit
question
question.data_attributes
question.selection_confirmation_text
question.content
question.selection_confirmation_text
question.data_attributes
question.content
question.data_attributes
question.number
question.id
sr = Repositories::SurveyRepository.new
survey = sr.find(7508)
survey.blueprint_id = 85
sr.update(survey)
survey = sr.find(7508)
sr.update(survey)
survey = sr.find(7508)
sr.update(survey)
survey.id
DatabaseModels
DatabaseModels::Survey.find(7508)
surv = DatabaseModels::Survey.find(7508)
surv.saev!
surv.save!
surv.blueprint_id = 85
surv.save!
survey = sr.find(7508)
surv = DatabaseModels::Survey.find(8705)
surv.blueprint_id = 85
surv.save!
surv.blueprint_id = 47
surv.save!
surv.blueprint_id = 85
surv.save!
surv.blueprint_id = 86
surv.save!
form_authenticity_token
source_file_path
target_file_path
config
Raven.configure
exit
or = Repositories::OrderRepository.new
order_repo = Repositories::OrderRepository.new
order_repo = Repositories::OrdersRepository.new
sr = Repositories::SurveyRepository.new
sr.last
sr.last.order_id
Survey.last
sr.within_order 209481
sr.within_order(209481).count
sr.within_order(209481)[0]
surv = _
surv.finished
surv.finished?
surv.finished_at.present?
surv.finished_at
surv
DatabaseModels::SurveyResponses.last
DatabaseModels::SurveyResponse.last
s_resp = _
s_resp.survey
s_resp
20.minutes.ago
exit
surv = DatabaseModels::Survey.last
surv.zappistore_id
exit
surv = DatabaseModels::Survey.last
from datacollector_development.survey_responses sr
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.last
survey.all_quotas_within_leeway?
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.last
survey.all_quotas_within_leeway?
quota.readable_value
leeway
quota.limit
quota
survey.quotas
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.last
survey.all_quotas_within_leeway?
exit
survey_repo = Repositories::SurveyRepository.new
survey.all_quotas_within_leeway?
survey = survey_repo.last
survey.all_quotas_within_leeway?
survey.quota_statuses
survey.send(:quota_statuses).first
survey.send(:quota_statuses)
survey = survey_repo.find(8716)
survey.send(:quota_statuses)
survey.send(:quota_statuses).first
survey.send(:quota_statuses)
statuses = _
survey.all_quotas_within_leeway?
exit
survey.all_quotas_within_leeway?
survey = survey_repo.find(8716)
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(8716)
survey.all_quotas_within_leeway?
key
statuses
survey.quota_statuses
survey
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
quota_name
quotas
quotas[quota_name]
{}[quota_value]
quota_value
(quotas[quota_name] || {})[quota_value] || 0
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
exit
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
quota_name
quotas
quotas[quota_name.name]
quota_name
quota_name.name
quotas
quota_name.name
quotas["supplier_code"]
quotas["supplier_code"][quota_value]
exit
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
exit
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
(quotas[quota_name] || {})[quota_value] || 0
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
quota.limit - ((leeway.to_f / 100) * quota.limit)
next
quota_statuses.get(key, quota.value) > target
quota_statuses.get(key, quota.value)
tarvet
target
target = quota.limit - ((leeway.to_f / 100) * quota.limit)
quota_statuses.get(key, quota.value) > target
up
exit
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
quota_key
quotas
leewa
leeway
quota_key
quotas.inject(result) { |res, quota| res && quota_within_leeway?(leeway, quota_key.name.to_s, quota) }
Survey.new
Survey.quotas
survey = Survey.new
survey.quotas
survey.has_quotas?
survey.all_quotas_within_leeway?
exit
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
survey.quotas
new_survey = Survey.ne
new_survey = Survey.new
db_survey = DatabaseModels::Survey.last
db_survey
db_survey.quotas
db_survey.quotas.class
survey.quota
survey.quotas
survey.quotas.class
Quotas.new({ "percent_leeway" => 10, "gender" => { "type" => "respondent_data", "1" => 75, "2" => 75 } })
quotas = _
survey
survey.quota_statuses
survey.send(:quota_statuses)
survey.quotas
survey.send(:quota_statuses)
survey.send(:quota_statuses).quotas
survey.send(:quota_statuses).quotas.class
Surveynew
Survey.new
survey.send(:quota_statuses).quotas.class
survey.send(:quota_statuses).class
rspec --format documentation spec/models/survey_spec.rb:98
exit
params
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
survey.initial_respondent_data_keys
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
params
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
self
params
quotas
survey.quota
survey.quotas
survey.quotas.each { |q| puts q.limit; }
each_quota.first
survey.each_quota.first
survey.each_quota
survey.quotas
survey.quota_keys
survey.quotas.each_quota
survey.quotas.each_quota(quota_keys)
survey.quotas.each_quota(survey.quota_keys)
exit
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716); survey.all_quotas_within_leeway?
params
enumerator
quota
quota_statuses.get(key, quota.value) > quota.minimum_for_leeway(leeway)
quotas.inject(result) { |res, quota| res && quota_within_leeway?(leeway, quota_key.name.to_s, quota) }
quotas
quota_within_leeway?(leeway, quota_key.name.to_s, quota)
quotas.inject(result) { |res, quota| res && quota_within_leeway?(leeway, quota_key.name.to_s, quota) }
quotas
quotas.inject(result) { |res, quota| res && quota_within_leeway?(leeway, quota_key.name.to_s, quota) }
quota_statuses.get(key, quota.value)
quota.minimum_for_leeway(leeway)
quota_statuses.get(key, quota.value) > quota.minimum_for_leeway(leeway)
quotas
quota_statuses.get(key, quota.value) > quota.minimum_for_leeway(leeway)
quota_statuses
enabled
limit
enumerator
quotas_for(quota_keys.first)
self
defined_quota
self[quota_key.first.name.to_s]
self[quota_keys.first.name.to_s]
defined_quota = self[quota_keys.first.name.to_s]
defined_quota.except(:type)
defined_quota.class
!nil
nil
survey
exit
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716);
survey.target
survey.target.panel_size
rspec --format documentation spec/models/survey_spec.rb:185
exit
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716);
survey.save!
survey.save
survey.completed_at = Time.now
survey_repo.update(survey)
exit
survey.completed?
survey.has_enough_completes?
survey
survey.all_quotas_within_leeway?
survey.has_enough_completes?
survey.class
survey.number_of_completes
survey.completed/
?
survey.completed?
exit
survey.has_enough_completes?
survey.all_quotas_within_leeway?
survey.has_enough_completes?
survey.all_quotas_within_leeway?
survey.has_enough_completes?
survey.all_quotas_within_leeway?
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
survey.id
survey.has_enough_completes?
kkkkrspec --format documentation /Users/deneshshan/Documents/work/zappi/data-collector.app/spec/controllers/survey_responses_controller_spec.rb:274
exit
survey.has_enough_completes?
survey.all_quotas_within_leeway?
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8716);
survey
survey.completed?
survey.complete?
survey.completed_at
survey.completed_at = Time.now
survey_repo.update(survey)
survey.completed?
survey.completed_at
exit
!survey.completed? && survey.has_enough_completes? && survey.all_quotas_within_leeway?
next
dummy_responses
dummy_responses.count
survey_response_repository.bulk_insert(dummy_responses)
unsent_responses
unsent_responses.count
unsent_responses.map(&:id)
next
survey.class
survey.completed?
exit
survey.quotas
quota_key
survey.class
context.try(:survey_response)
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.last
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.last; survey_response_repo = Repositories::SurveyResponseRepository.new
survey.order(survey_repository: survey_repo).surveys
survey.order(survey_repository: survey_repo).surveys.count
survey.order(survey_repository: survey_repo).surveys.first.id
survey.id
[1,2,3,4,5,6]
arr = _
arr.last 
survey
survey.quotas
survey.quota
survey.quotas
DatabaseModels::QuotaStatus.last
DatabaseModels::QuotaStatus.all
quota_key
current
find_quota_status
quota_status_repository
quota_status_repository.find_by_survey_id(survey.id)
quota_status_repository.last
quota_status_repository.backend
quota_status_repository.backend.last
quota_status_repository.backend.all
DatabaseModels::QuotaStatus
DatabaseModels::QuotaStatus.last
DatabaseModels::QuotaStatus.all
attributes
attributes.fetch(:quotas)
attributes
survey.panel_size
survey.target
survey.target.panel_size
survey.number_of_completes
survey.has_enough_completes?
exit1
DatabaseModels::SurveyResponse.all
DatabaseModels::SurveyResponse.all.count
data
data.count
DatabaseModels::SurveyResponse.all.count
survey.completed?
survey.number_of_completes
survey.all_quotas_within_leeway?
survey.quotas
135
rspec --format documentation spec/features/survey_can_be_set_as_complete_spec.rb:61
click_on 'Blue'
choose 'Blue'
survey.completed?
survey.number_of_completes
survey.all_quotas_within_leeway?
quota
quota_within_leeway?(quotas.percent_leeway, quota_key.name.to_s, quota)
quota_key
quota_key.name.to_s
quota
quotas.percent_leeway
quota_statuses
survey_response_repo
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_response_repo.send(:finished_records_for, survey)
survey_repo = Repositories::SurveyRepository.new; survey_response_repo = Repositories::SurveyResponseRepository.new; survey = survey_repo.last
survey_response_repo.finished(survey)
survey_response_repo.send(:finished_records_for_survey, survey)
surv_response_backend = Repositories::Database::SurveyResponseBackend.new
Repositories
Repositories::Database
surv_response_backend = Repositories::Backends::Database::SurveyResponseBackend.new
survey_response_backend.send(:finished_records_for_survey, survey)
surv_response_backend.send(:finished_records_for_survey, survey)
survey_repo.last
_.class
survey_repo.find(8726)
_.class
uota_status_repo = Repositories::QuotaStatusRepository.new
quota_status_repo = Repositories::QuotaStatusRepository.new
quota_status_repo.all
quota_status_repo.last
quota_status_repo.find_by_survey_id(8707)
DatabaseModels::QuotaStatus.last
DatabaseModels::QuotaStatus.where(survey_id: 8707)
quotas = _.quotas
wq = DatabaseModels::QuotaStatus.where(survey_id: 8707)
qs = DatabaseModels::QuotaStatus.where(survey_id: 8707)
qs[:quotas]
qs.id
qs.class
qs.first.quotas
qs.first.quotas["age"]
qs.first.quotas["age"].first
qs.first.quotas["age"].first[0]
qs.first.quotas["age"].first[0].class
qs.first
survey
survey.number_completes
survey.number_of_completes
survey_response_repo
survey_response_repo.finished(survey)
survey_repo.find(8707)
survey_response_repo.finished(survey)
survey_repo.find(8716)
survey_response_repo.finished(survey)
survey
survey = survey_repo.find(8716)
survey_response_repo.finished(survey)
survey = surey_response_repo.find(8726)
survey = sureyrepo.find(8726)
survey = survey_repo.find(8726)
Services::DummyResponsesCreator.new(survey.id).call
survey_response_repo.finished_count(survey)
survey_response_repo.finished(survey)
(18..25).sample
(18..25).to_a.sample
exit
survey
survey.send(:quota_statuses)
next
survey.send(:quota_statuses)
survey_response.quota_status
SurveyResponse::QUOTA_FAIL
SurveyResponse::QUOTA_COMPLETE
survey.send(:quota_statuses)
survey.has_enough_completes?
survey.numer_of_completes
survey.number_of_completes
exit
survey.number_of_completes
survey.has_enough_completes?
survey.all_quotas_within_leeway?
key
quota
survey.all_quotas_within_leeway?
quota_statuses.get(key, quota.value)
quota.minimum_for_leeway(leeway)
survey.all_quotas_within_leeway?
key
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
eky
key
quota_statuses.get(key, quota.value)
quota
quota.value
quota_statuses.get(key, quota.value)
key
quota_statuses.get(key, quota.value)
quota.value
quota_statuses
quota_statuses.class
quota_statuses.quotas
quota_statuses.quotas[key]
quota_statuses.quotas[key][quota.value]
quota_statuses.quotas[key]
quota_statuses.quotas[key].first
quota_statuses.quotas[key].first[0].class
quota_statuses.quotas[key].first[0].to_s
quota_statuses.get(key, quota.value)
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
quota_statuses.get(key, quota.value)
key
quota.value
quotas
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
key
quota.vale
quota.value
quota_statuses
key
quota_statuses.quotas[key]
quota_statuses.quotas[key][quota.value]
quota.value
quota_statuses.quotas[key][quota.value]
key
quota_statuses.quotas[key][quota.value]
survey.completed?
survey.has_enough_completes?
survey.all_quotas_within_leeway?
quota_within_leeway?(quotas.percent_leeway, quota_key.name.to_s, quota)
quota.key
quota_key
quota_key.name
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
quota_statuses.get(quota_key.name.to_s, quota.value) >= quota.minimum_for_leeway(leeway)
quota_statuses.get(quota_key.name.to_s, quota.value) >= quota.minimum_for_leeway(quotas.percent_leeway)
quota_statuses.get(key, quota.value)
quota_statuses.get(quota_key.name.to_s, quota.value)
quota.minimum_for_leeway(quotas.percent_leeway)
key
quota_statuses.get(key, quota.value)
matching_quota_keys_and_quotas
survey.each_quota
quotas = _
quatos.next
quatas.next
quotas = survey.each_quota
quatas.next
quotas.next
ages = _
ages[1].find { |q| q.value == value }
ages[1].find { |q| q.value == 27 }
(0..99) == 27
ages[1][0]
ages[1][0].value = (18..25)
ages[1][1].value = (26..35)
ages[1].find{ |q| q.value == 27 }
ages[1].find{ |q| q.value == '27' }
exit
value
next
value
quota_key
next
quota_key
value
quota_key
value
next
nex
next
quota
value
next
survey.completed?
survey.all_quotas_within_leeway?
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
quota_statuses
quota_statuses.get(key, quota.value)
key
quota_statuses.get(key, quota.value)
next
new(survey, survey_response, options)
calc = _
service.quota_success?
key
quota_statuses.get(key, quota.value)
key
quota_statuses.get(key, quota.value)
quota.value
quota_statuses.get(key, quota.value)
quota.value
!survey.completed? && survey.has_enough_completes? && survey.all_quotas_within_leeway?
!survey.completed? && survey.has_enough_completes?
survey.all_quotas_within_leeway?
.completed? && survey.has_enough_completes? && survey.all_quotas_within_leeway?
!survey.completed? && survey.has_enough_completes? && survey.all_quotas_within_leeway?
attrs
survey.completed_at
attrs
InsightOutServices::InsightOutCommunicationService::COMPLETE_SCHEDULE_TIME
exit
expect(page).to have_content('Intro page')
bbrspec --format documentation spec/features/survey_can_be_set_as_complete_spec.rb:98
rspec --format documentation spec/features/survey_can_be_set_as_complete_spec.rb:98
result
!survey.completed?
survey.has_enough_completes?
survey.all_quotas_within_leeway?
current
target
key
quota.value
current
target
current
target
current
target
current
target
survey_response.can_complete?(survey)
next
!survey_response.can_complete?(survey)
next
answer_sheet.completed?
next
survey_response
next
current = find_quota_status.get(quota_name_for(quota_key), quota.value)
quota.limit + quota_margin(quota_key, quota.limit)
current >= quota.limit + quota_margin(quota_key, quota.limit)
quota_key
matching_quota_keys_and_quotas.none? do |quota_key, quota| end
matching_quota_keys_and_quotas.none?
matching_quota_keys_and_quotas.none? do end 
false do end
[].any?
[].any? do end
[].none? do end
matching_quota_keys.none?
matching_quota_keys_and_quotas.none? do |quota_key, quota|
  if quota_exceeded_max?(quota_key, quota)
    survey_response.quota_failure_cause = quota_name_for(quota_key)
    true
  end
end
matching_quota_keys_and_quotas.none? do |quota_key, quota|
  if quota_exceeded_max?(quota_key, quota)
    survey_response.quota_failure_cause = quota_name_for(quota_key)
    true
  end
end
current >= quota.limit + quota_margin(quota_key, quota.limit)
current = find_quota_status.get(quota_name_for(quota_key), quota.value)
current >= quota.limit + quota_margin(quota_key, quota.limit)
current = find_quota_status.get(quota_name_for(quota_key), quota.value)
current >= quota.limit + quota_margin(quota_key, quota.limit)
12 * 1.1
survey_repo = Repositories::SurveyRepository.new; survey_response_repo = Repositories::SurveyResponseRepository.new; survey = survey_repo.last
surv_response_backend = Repositories::Backends::Database::SurveyResponseBackend.new
quota_status_repo = Repositories::QuotaStatusRepository.new
quota_status_repo.find_by_survey_id(survey.id)
survey = survey_repo
survey = survey_repo.find(8716)
quota_status_repo.find_by_survey_id(8716)
survey.quotas
h1 = { age: 27, gender: '1' }
h2  = { gender: '2' }
h1.merge(h2)
h1.merge({})
h1.merge!({})
h1
h1.merge!(h2)
h1
{}.merge(h1)
h1(:age)
h1.fetch(:age)
]j
exit
Time.now
survey_response.can_complete?(survey)
next
caller.reject{ |x| x.include?('gem') }
exit
survey_response.terminated? || survey_response.duplicated? || !survey.completed?
survey.completed?
exit
survey = survey_repo.find(8716)
survey = survey_repo.find(1)
order_surveys
order_surveys.last
order_surveys.last.id
rspec --format documentation spec/lib/jobs/batch_dispatch_responses_spec.rb:31
exit
order_surveys
thing = (1..10)
thing.peek
thing = (1..10).to_enum
thing.next
thing.peek
thing.next
thing.peek
thing.next
thing.peek
val = thing.peek
val
(1..10).each { |e| e.next }
(1..10).each { |e| puts e.next }
(1..10).to_a.each { |e| puts e.next }
(1..10).to_a.each { |e| puts e.peek }
(1..10).to_a.next
(1..10).next
survey.finished?
survey.has_enough_completes?
survey.number_of_completes
next
survey.has_enough_completes?
survey.finished?
survey.all_quotas_within_leeway?
key
quota_statuses.get(key, quota.value)
quota.minimum_for_leeway(leeway)
survey.all_quotas_within_leeway?
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
quota_statuses.get(key, quota.value)
quota.minimum_for_leeway(leeway)
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
survey_ready_for_complete?
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
order_surveys
order_surveys.count
order_surveys[0]
order_surveys[0].inspect
order_surveys[1].inspect
order_surveys[2].inspect
order_surveys[3].inspect
order_surveys[0].inspect
order_surveys[3].inspect
order_surveys[1].inspect
order_surveys[2].inspect
exit
survey = Repositories::SurveyRepository.find(8726)
survey = Repositories::SurveyRepository.new.find(8726)
exit
survey = Repositories::SurveyRepository.new.find(8726)
survey.finished?
survey.finished_at = nil
Repositories::SurveyRepository.new.update(survey)
survey = Repositories::SurveyRepository.new.find(8726)
survey.finished?
Resque
Resque.enqueue(Jobs::BatchDispatchResponses, 8726, true)rspec --format documentation spec/lib/jobs/batch_dispatch_responses_spec.rb
rspec --format documentation spec/lib/jobs/batch_dispatch_responses_spec.rb
Resque.enqueue(Jobs::BatchDispatchResponses, 8726, true)
survey_response.quota_failed?
survey.finished?
survey.finished_at = nil
survey_repo
survey_repo.update(survey)
next
survey_response.can_complete? survey
survey_ready_for_complete? && !survey.demo?
survey_ready_for_complete?
!survey.finished? && survey.has_enough_completes? && survey.all_quotas_within_leeway?
survey.finished?
survey.has_enough_completes?
urvey.all_quotas_within_leeway?
survey.all_quotas_within_leeway?
survey.finished?
survey.finished_at = nil
survey_repo.update(survey)
next
survey_ready_for_complete?
survey.has_enough_completes?
survey.all_quotas_within_leeway?
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
key
quota.value
quota_statuses.get(key, quota.value)
quota.minimum_for_leeway(leeway)
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8730)
survey.finished?
DatabaseModels::SurveyReposonses.where(survey_id: 8730)
DatabaseModels::SurveyReposonse.where(survey_id: 8730)
DatabaseModels::SurveyReposonse
DatabaseModels::SurveyResponse
DatabaseModels::SurveyResponse.where(survey_id: 8730)
DatabaseModels::SurveyResponse.where(survey_id: 8730, gender: "0")
genders = DatabaseModels::SurveyResponse.where(survey_id: 8730, gender: "0")
genders.update_all(gender: "2")
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8730)
survey.all_quotas_within_leeway?
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8730)
survey.all_quotas_within_leeway?
exit
Product.all
uni = Product.find(27)
uni.code
uni.code.camelize
CheckoutSystemModels::ProductSetups.const_get(uni.code.camelize}Setup")
CheckoutSystemModels::ProductSetups.const_get("#{uni.code.camelize}Setup")
uni.sdk_definition
uni.send(:sdk_definition)
uni.sdk_enabled = true
uni.save!
survey.target.enough_responses?(finished_responses_count, false)
next
survey.target.enough_responses?(finished_responses_count, false)
ProjectSetup::Cart.destroy_all
exit
Order.last
exit
Order.last
Order.last(10)
Order.last
Order.last.order_data
Order.last(2)
exit
exit
Order.last
Order.last.error
Order.last.errmsg
order.processing_result
Order.last.processing_result
Order.last.processing_result.result
exit
user = AdminUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
user.add_role :super_admin
user.save!
exit
adapted_data
expected_data
adapted_data
expected_data - adapted_data
expected_data
adapted_data
adapted_data.class
exit
exit!
adapted_data
common_data
adapted_data
exit
exit!
adapted_data == expect_data
adapted_data
exit!
adapted_data
exit!
jjjjjj
adapted_data
exit!
adapted_data
exit!
adapted_data
definition
exit!
adapted_data
Order.last
order = Order.last
order.product_setup
order.product_setups
order.product_setups[0]
exit!
exit!
adapted_data
exit!
adapted_data
exit!
adapted_data
exit!
adapted_data
expected_data
expected_data.merge(common_data)
adapted_data == expected_data
adapted_data
File.open("tmp/adapted.rb", "w+") { |f| f.write(adapted_data) }
File.open("tmp/adapted.rb", "w+") { |f| f.write(PP.pp(adapted_data)) }
File.open("tmp/adapted.rb", "w+") { |f| f.write(adapted_data.to_yaml) }
File.open("tmp/expected.yml", "w+") { |f| f.write(expected_data.merge(common_data).to_yaml) }
expected_data
expected_data.class
expected_data.diff(expected_data.merge(common_data))
ex = expected_data.merge(common_data)
ex.class
adapted_data.sort_by { |key, value| key }
ad_arr = _
ex_arr = ex.sort_by{ |key, value|  key }
ad_arr - ex_arr
ex_arr - ad_arr
adapted_data
Services::DummyResponsesGenerator
SurveyResponse.last
DatabaseModels::SurveyResponse.last
DatabaseModels::QuotaStatuses
DatabaseModels::QuotaStatus
DatabaseModels::QuotaStatus.last
DatabaseModels::QuotaStatus.last(10)
DatabaseModels::QuotaStatus.last(100)
DatabaseModels::QuotaStatus.find(8444)
qs = _
qs.get("supplier_code")
qs.get("supplier_code", "Fulcrum")
qs
qs.class
Respositories::QuotaStatusRepository
Repositories::QuotaStatusRepository
Repositories::QuotaStatusRepository.find(8444)
Repositories::QuotaStatusRepository.find_by_survey_id(8634)
Repositories::QuotaStatusRepository.new.find_by_survey_id(8444)
Repositories::QuotaStatusRepository.new.find_by_survey_id(8364)
qs = _
qs.get("supplier_code", "Fulcrum")
qs
qs.id
qs.all
qs.inspect
qs.to_yaml
Repositories::QuotaStatusRepository.new.find_by_survey_id(8444)
Repositories::QuotaStatusRepository.new.find_by_survey_id(8634)
qs.get("supplier_code", "Fulcrum")
qs.get("supplier_code", "5529")
qs.quotas
qs = Repositories::QuotaStatusRepository.new.find_by_survey_id(8634)
qs.get("supplier_code", "5529")
qs.get("supplier_code", "Fulcrum")
opts = { fuck: "u" )
opts = { fuck: "u" }
opts.fetch(:lol)
if fuck = opts.delete(:fuck) raise "fuck" end
opts
exit
services_brand_usage_answer_options_heard_but_never_used*")
Services::DummyResponsesGenerator
generator = Services::DummyResponsesGenerator.new
survey = Repositories::SurveyRepository.new.find set guifont=DejaVu_Sans_Mono_for_Powerline:h10
survey = Repositories::SurveyRepository.new.find 8729
survey
generator = Services::DummyResponsesGenerator.new survey
opts = { gender: [1,2], ages: (18..25), suppliers: { "Fulcrum" => 3, "5548" => 3, "5529" => 3, "5347" => 3 }, size: 12 }
generator.call(opts)
exit
survey = Repositories::SurveyRepository.new.find 8729
generator = Services::DummyResponsesGenerator.new survey
opts = { gender: [1,2], ages: (18..25), suppliers: { "Fulcrum" => 3, "5548" => 3, "5529" => 3, "5347" => 3 }, size: 12 }
generator.call opts
exit
quota_key
quota_key.name
quota_status
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
opts = { gender: [1,2], ages: [(18..25),(46-55)], suppliers: { "Fulcrum" => 3, "5548" => 3, "5529" => 3, "5347" => 3 }, size: 12 }
responses = generator.call opts
age_range
ages
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
opts = { gender: [1,2], ages: [(18..25),(46..55)], suppliers: { "Fulcrum" => 3, "5548" => 3, "5529" => 3, "5347" => 3 }, size: 12 }
responses = generator.call opts
ages
age_range
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
opts = { gender: [1,2], ages: [(18..25),(46..55)], suppliers: { "Fulcrum" => 3, "5548" => 3, "5529" => 3, "5347" => 3 }, size: 12 }
responses = generator.call opts
age
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
age_ranges = [(18..25), (26..35), (36..45), (46..55), (56..75)]
opts = { gender: [1,2], ages: age_ranges, suppliers: { "Fulcrum" => 37, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
response.valid??
response.valid?
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
values
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
hash
key
values
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
opts
hash
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
opts
hash
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
hash
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
hash
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
values
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
opts
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
data
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
data
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
survey_response_repo.bulk_insert(responses)
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
statuses
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
survey = Repositories::SurveyRepository.new.find 8729
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..25) => 40, (26..35) => 30, (36..45) => 32, (46..55) => 30, (56..75) => 17 }
opts = { gender: genders, age: age_ranges, supplier_code: { "Fulcrum" => 0, "5548" => 37, "5529" => 37, "5347" => 37 }, size: 148 }
responses = generator.call opts
statuses
quota_status
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
supliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call opts
opts
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
opts
statuses
values
statuses
quota_status_repo.update(statuses)
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
statuses
quota_status
survey
survey.id
QuotaStatus.empty(survey.id)
QuotaStatus.empty(survey)
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
statuses
survey
Repositories::QuotaStatusRepository.new.find_by_survey_id(8634)
QuotaStatus.empty(survey)
status = QuotaStatus.empty(survey)
status
statuses
next
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
statuses
value
quota.value
quota_status
exit
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
quota_statuses
status = QuotaStatus.empty(survey)
Services::QuotaCalculator.new(survey).reset_quota_status
status = quota_status
status = quota_statuses
status
Services::QuotaCalculator.new(survey).reset_quota_status
survey
status = quota_statuses
status = QuotaStatus.empty(survey)
quota_status_repo.update(statuses)
quota_status_repo.update(status)
statuses = quota_statuses
statuses
lsurvey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
status = QuotaStatus.empty(survey)
quota_status_repo.update(statuses)
quota_status_repo.update(status)
statuses
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
exit
survey_repository = Repositories::SurveyRepository.new
survey = survey_repository.find(8726)
generator = Services::DummyResponsesGenerator.new(survey)
dummy_responses = generator.call
opts
next
Services::DummyResponsesCreator.new(8726).call
exit
Customer.last
CustomerIdentity.last
Customer.last.customer_group
CustomerGroup.las
CustomerGroup.last
Customer.last.customer_groups
exit
survey.finished?
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
survey.finished?
survey
dbserv = DatabaseModels::Survey.find survey.id
dbserv.blueprint_id
dbserv.blueprint_id = 85
dbserv.save!
exit
survey_ready_for_complete?
next
survey_ready_for_complete?
survey.reload
survey_repo
sur2 = survey_repo.find survey.id
sur2.has_enough_completes?
sur2.all_quotas_within_leeway?
survey.quotas
Repositories::QuotaStatusRepository
quota_status_repo = Repositories::QuotaStatusRepository.new
quota_status_repo.find_by_survey_id sur2.id
sur2.all_quotas_within_leeway?
survey = Repositories::SurveyRepository.new.find 8726
survey.finished?
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
exit
next
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
key
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
quota.value
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
exit
@survey.all_quotas_within_leeway?
quota_statuses.get(key, quota.value) >= quota.minimum_for_leeway(leeway)
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
exit
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
survey.save!
exit
next
survey.has_enough_completes?
survey.all_quotas_within_leeway?
survey.finished?
next
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
survey.sent?
survey.sent = nil
survey.sent_at = nil
survey_repo = Repositories::SurveyRepository.new
survey_repo.update survey
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
exit
survey_ready_for_complete?
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 89, "5347" => 69 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
exit
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
exit
respondent
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
DatabaseModels::SurveyResponse.last
exit
e.message.include?("UTF-8")
next
exnt
next
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
exit
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
ConnectionLogs
survey_repo = Repositories::SurveyRepository.new
survey.sent_at = nil
survey_repo.update survey
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
genders = { 1 => 68, 2 => 68 }
age_ranges = {(18..34) => 67, (35..44) => 52, (45..54) => 15 }
suppliers = { "Fulcrum" => 0, "5548" => 2, "5529" => 90, "5347" => 44 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
survey.finished?
survey.all_quotas_within_leeway?
survey.sent_at = nil
survey_repo.update survey
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 89, "5347" => 69 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
survey.send?
survey.sent?
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 74, 2 => 74 }
age_ranges = {(18..34) => 68, (35..44) => 52, (45..54) => 29 }
suppliers = { "Fulcrum" => 0, "5548" => 14, "5529" => 89, "5347" => 45 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 148 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
survey = Repositories::SurveyRepository.new.find 8726
survey.finished?
exit
survey_repo = Repositories::SurveyRepository.new
survey = Repositories::SurveyRepository.new.find 8726
order_surveys = survey.order(survey_repository: survey_repo).surveys
survey_responses = survey_response_repo.ready_for_sending(order_surveys.first)
survey_response_repo = Repositories::SurveyResponseRepository.new; 
order_surveys = survey.order(survey_repository: survey_repo).surveys
survey_responses = survey_response_repo.ready_for_sending(order_surveys.first)
records
exportable_records_for_survey(survey).not_sent.includes(:question_responses)
exportable_records_for_survey(survey)
exportable_records_for_survey(survey).not_sent
exportable_records_for_survey(survey).not_sent.includes(:question_responses)
jjrecords = exportable_records_for_survey(survey).not_sent.includes(:question_responses)
j          records = records.where(id: options[:survey_response_id]) if options[:survey_response_id]
records = records.page(options[:page]).per(options[:per_page]) if options[:page] && options[:per_page]
k          records = exportable_records_for_survey(survey).not_sent.includes(:question_responses)
records = exportable_records_for_survey(survey).not_sent.includes(:question_responses)
jrecords.where(id: options[:survey_response_id]) if options[:survey_response_id]
records
records = records.where(id: options[:survey_response_id]) if options[:survey_response_id]
records
jjw
Jobs::BatchDispathResponses.perform(survey.id
)
Jobs::BatchDispatchResponses
survey.id
Jobs::BatchDispatchResponses(survey.id, true)
Jobs::BatchDispatchResponses.perform(survey.id, true)
record
records
Jobs::BatchDispatchResponses.perform(survey.id, true)
Jobs::UpdateInsightOutReport.perform(8726, 2018488, {"mark_as_complete"=>true})
records
exit
Jobs::UpdateInsightOutReport.perform(8726, DatabaseModels::SurveyResponse.last.id, {"mark_as_complete"=>true})
options
exit
Jobs::UpdateInsightOutReport.perform(8726, DatabaseModels::SurveyResponse.last.id, {"mark_as_complete"=>true})
options
options[:mark_as_complete]
args
Jobs::UpdateInsightOutReport.perform(8726, DatabaseModels::SurveyResponse.last.id, {"mark_as_complete"=>true})
args
exit
Jobs::UpdateInsightOutReport.perform(8726, DatabaseModels::SurveyResponse.last.id, {"mark_as_complete"=>true})
options
exit
Jobs::UpdateInsightOutReport.perform(8726, DatabaseModels::SurveyResponse.last.id, {"mark_as_complete"=>true})
args
Jobs::UpdateInsightOutReport.perform(8726, DatabaseModels::SurveyResponse.last.id, {"mark_as_complete"=>true})
exit
Jobs::UpdateInsightOutReport.perform(8726, DatabaseModels::SurveyResponse.last.id, {"mark_as_complete"=>true})
options
options.fetch(:mark_as_complete)
options.with_indifferent_access.fetch(:mark_as_complete)
args
args.with_indifferent_access.fetch(:mark_as_complete) { false }
options[:complete]
Jobs::BatchDispatchResponses.perform(survey.id, true)
survey_repo = Repositories::SurveyRepository.new
survey = Repositories::SurveyRepository.new.find 8726
Jobs::BatchDispatchResponses.perform(survey.id, true)
exit
Rails.cache.fetch(cache_key) do
  7:       yield
8:     end
exit
config = '{
  "product_category_id": 1,
  "media_exposure": [
    {
      "group_name": "group_cinema",
      "answer_text": "cinema",
      "answer_id": 1
    },
    {
      "group_name": "group_press",
      "answer_text": "paper_magazine_newspaper",
      "answer_id": 5
    },
    {
      "group_name": "group_press",
      "answer_text": "online_magazine_newspaper",
      "answer_id": 6
    },
    {
      "group_name": "group_internet",
      "answer_text": "internet_desktop",
      "answer_id": 9
    },
    {
      "group_name": "group_internet",
      "answer_text": "internet_mobile",
      "answer_id": 10
    },
    {
      "group_name": "group_transport",
      "answer_text": "transport",
      "answer_id": 13
    },
    {
      "group_name": "group_event",
      "answer_text": "event",
      "answer_id": 14
    }
  ],
  "display_video_screener": 0,
  "screening_questions": [],
  "screening_conditions": "false",
  "screening_quota": {},
  "device_quota": {}
}'
config
dbsurvey = DatabaseModels::Survey.find 9022
exit
config = '{
  "product_category_id": 1,
  "media_exposure": [
    {
      "group_name": "group_cinema",
      "answer_text": "cinema",
      "answer_id": 1
    },
    {
      "group_name": "group_press",
      "answer_text": "paper_magazine_newspaper",
      "answer_id": 5
    },
    {
      "group_name": "group_press",
      "answer_text": "online_magazine_newspaper",
      "answer_id": 6
    },
    {
      "group_name": "group_internet",
      "answer_text": "internet_desktop",
      "answer_id": 9
    },
    {
      "group_name": "group_internet",
      "answer_text": "internet_mobile",
      "answer_id": 10
    },
    {
      "group_name": "group_transport",
      "answer_text": "transport",
      "answer_id": 13
    },
    {
      "group_name": "group_event",
      "answer_text": "event",
      "answer_id": 14
    }
  ],
  "display_video_screener": 0,
  "screening_questions": [],
  "screening_conditions": "false",
  "screening_quota": {},
  "device_quota": {}
}'
dbsurv = DatabaseModels::Survey.find 9022
dbsurv.configuration_data
dbsurv.configuration_data = config
dbsurv.save!
dbsurv.configuration_data.class
dbsurv.configuration_data
dbsurv = DatabaseModels::Survey.find 9022
dbsurv.configuration_data.class
dbsurv.configuration_data = {
  "product_category_id": 1,
"media_exposure": [
{
  "group_name": "group_cinema",
"answer_text": "cinema",
"answer_id": 1
},
{
  "group_name": "group_press",
"answer_text": "paper_magazine_newspaper",
"answer_id": 5
},
{
  "group_name": "group_press",
"answer_text": "online_magazine_newspaper",
"answer_id": 6
},
{
  "group_name": "group_internet",
"answer_text": "internet_desktop",
"answer_id": 9
},
{
  "group_name": "group_internet",
"answer_text": "internet_mobile",
"answer_id": 10
},
{
  "group_name": "group_transport",
"answer_text": "transport",
"answer_id": 13
},
{
  "group_name": "group_event",
"answer_text": "event",
"answer_id": 14
}
],
"display_video_screener": 0,
"screening_questions": [],
"screening_conditions": "false",
"screening_quota": {},
"device_quota": {}
}
hash = {
  "product_category_id": 1,
"media_exposure": [
{
  "group_name": "group_cinema",
"answer_text": "cinema",
"answer_id": 1
},
{
  "group_name": "group_press",
"answer_text": "paper_magazine_newspaper",
"answer_id": 5
},
{
  "group_name": "group_press",
"answer_text": "online_magazine_newspaper",
"answer_id": 6
},
{
  "group_name": "group_internet",
"answer_text": "internet_desktop",
"answer_id": 9
},
{
  "group_name": "group_internet",
"answer_text": "internet_mobile",
"answer_id": 10
},
{
  "group_name": "group_transport",
"answer_text": "transport",
"answer_id": 13
},
{
  "group_name": "group_event",
"answer_text": "event",
"answer_id": 14
}
],
"display_video_screener": 0,
"screening_questions": [],
"screening_conditions": "false",
"screening_quota": {},
"device_quota": {}
}
hash = {
  "product_category_id": 1,
"media_exposure": [
{
  "group_name": "group_cinema",
"answer_text": "cinema",
"answer_id": 1
},
{
  "group_name": "group_press",
"answer_text": "paper_magazine_newspaper",
"answer_id": 5
},
{
  "group_name": "group_press",
"answer_text": "online_magazine_newspaper",
"answer_id": 6
},
{
  "group_name": "group_internet",
"answer_text": "internet_desktop",
"answer_id": 9
},
{
  "group_name": "group_internet",
"answer_text": "internet_mobile",
"answer_id": 10
},
{
  "group_name": "group_transport",
"answer_text": "transport",
"answer_id": 13
},
{
  "group_name": "group_event",
"answer_text": "event",
"answer_id": 14
}
],
"display_video_screener": 0,
"screening_questions": [],
"screening_conditions": "false",
"screening_quota": {},
"device_quota": {}
}
hash  { "product_category_id": 1, "media_exposure": [ { "group_name": "group_cinema", "answer_text": "cinema", "answer_id": 1 }, { "group_name": "group_press", "answer_text": "paper_magazine_newspaper", "answer_id": 5 }, { "group_name": "group_press", "answer_text": "online_magazine_newspaper", "answer_id": 6 }, { "group_name": "group_internet", "answer_text": "internet_desktop", "answer_id": 9 }, { "group_name": "group_internet", "answer_text": "internet_mobile", "answer_id": 10 }, { "group_name": "group_transport", "answer_text": "transport", "answer_id": 13 }, { "group_name": "group_event", "answer_text": "event", "answer_id": 14 } ], "display_video_screener": 0, "screening_questions": [], "screening_conditions": "false", "screening_quota": {}, "device_quota": {} }
hash = { "product_category_id": 1, "media_exposure": [ { "group_name": "group_cinema", "answer_text": "cinema", "answer_id": 1 }, { "group_name": "group_press", "answer_text": "paper_magazine_newspaper", "answer_id": 5 }, { "group_name": "group_press", "answer_text": "online_magazine_newspaper", "answer_id": 6 }, { "group_name": "group_internet", "answer_text": "internet_desktop", "answer_id": 9 }, { "group_name": "group_internet", "answer_text": "internet_mobile", "answer_id": 10 }, { "group_name": "group_transport", "answer_text": "transport", "answer_id": 13 }, { "group_name": "group_event", "answer_text": "event", "answer_id": 14 } ], "display_video_screener": 0, "screening_questions": [], "screening_conditions": "false", "screening_quota": {}, "device_quota": {} }
hash = { "product_category_id" =>  1, "media_exposure" =>  [ { "group_name" =>  "group_cinema", "answer_text" =>  "cinema", "answer_id" =>  1 }, { "group_name" =>  "group_press", "answer_text" =>  "paper_magazine_newspaper", "answer_id" =>  5 }, { "group_name" =>  "group_press", "answer_text" =>  "online_magazine_newspaper", "answer_id" =>  6 }, { "group_name" =>  "group_internet", "answer_text" =>  "internet_desktop", "answer_id" =>  9 }, { "group_name" =>  "group_internet", "answer_text" =>  "internet_mobile", "answer_id" =>  10 }, { "group_name" =>  "group_transport", "answer_text" =>  "transport", "answer_id" =>  13 }, { "group_name" =>  "group_event", "answer_text" =>  "event", "answer_id" =>  14 } ], "display_video_screener" =>  0, "screening_questions" =>  [], "screening_conditions" =>  "false", "screening_quota" =>  {}, "device_quota" =>  {} }
dbsurv.configuration_data = { "product_category_id" =>  1, "media_exposure" =>  [ { "group_name" =>  "group_cinema", "answer_text" =>  "cinema", "answer_id" =>  1 }, { "group_name" =>  "group_press", "answer_text" =>  "paper_magazine_newspaper", "answer_id" =>  5 }, { "group_name" =>  "group_press", "answer_text" =>  "online_magazine_newspaper", "answer_id" =>  6 }, { "group_name" =>  "group_internet", "answer_text" =>  "internet_desktop", "answer_id" =>  9 }, { "group_name" =>  "group_internet", "answer_text" =>  "internet_mobile", "answer_id" =>  10 }, { "group_name" =>  "group_transport", "answer_text" =>  "transport", "answer_id" =>  13 }, { "group_name" =>  "group_event", "answer_text" =>  "event", "answer_id" =>  14 } ], "display_video_screener" =>  0, "screening_questions" =>  [], "screening_conditions" =>  "false", "screening_quota" =>  {}, "device_quota" =>  {} }
dbsurv.save!
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 8852
survey.target.panel_size
survey_response_repo = Repositories::SurveyResponseRepository.new; 
survey_response_repo.finished_count(survey)
finished = _
survey.target.enough_responses?(finished, false)
orders_products
orders.page(params[:page]).per(params[:per_page])
content
label
group_question.answer_options
caller.reject{ |x| x.include?('gem') }
key
keys
caller.reject{ |x| x.include?('gem') }
up
keys
up
content
caller.reject{ |x| x.include?('gem') }
up
labels
translation_root
up
content
translator.class
translations
translator.class
translator
down
def generate_bank(translation_hash)
  TranslationBank.new(translation_root).tap do |bank|
    required_translations.each do |key|
      bank.add(key, default: translation_hash[key])
    end
    (translation_hash.keys & optional_translations).each do |key|
      bank.add(key, default: translation_hash[key])
    end
  end
end
TranslationBank.new(translation_root).tap do |bank|
  required_translations.each do |key|
    bank.add(key, default: translation_hash[key])
  end
  (translation_hash.keys & optional_translations).each do |key|
    bank.add(key, default: translation_hash[key])
  end
end
translation_hash = { }
TranslationBank.new(translation_root).tap do |bank|
  required_translations.each do |key|
    bank.add(key, default: translation_hash[key])
  end
  (translation_hash.keys & optional_translations).each do |key|
    bank.add(key, default: translation_hash[key])
  end
end
translation_root
up
translation_root
parent_labels
translation_leaf
label
up
down
caller.reject{ |x| x.include?('gem') }
up
question_generator.label
options[:appended_question_attributes][:text]
options[:appended_question_attributes][:options][:fixed]
options
options[:label]
options[:appended_question_attributes][:label]
exit
id
counter.generate
id
options
caller.reject{ |x| x.include?('gem') }
label_id
next
label_id
options
options[:appended_question_attributes][:id]
options[:appended_question_attributes]
options[:appended_question_attributes][:id]
options[:appended_question_attributes]
options[:appended_question_attributes].keys
options[:appended_question_attributes][:fuck_u][:id]
caller.reject{ |x| x.include?('gem') }
up
down
options.try(:appended_question_attributes)
options.class
options[:appended_question_attributes]
options[:appended_question_attributes].try(:[], :options)
options[:appended_question_attributes].try(:[], :options).try(:[], :id)
expect(page.find("#answer_option_666")).to have_content("lol")
page.find('answer_option_666')
page.find('question_answer_666')
page.find('#question_answer_666')
expect(page.find('#question_answer_666')).to have_content('None of them...')
page.find('#question_answer_666').content
page.find('#question_answer_666').html
page.find('#question_answer_666').class
page.find('#question_answer_666').text
page.find('#question_answer_666').value
page.find('#question_answer_666').parent
page.find('#question_answer_666').parent.text
page.find('#question_answer_666')
page.find('#question_answer_666').parent('label')
page.find('#question_answer_666').parent
page.find('#question_answer_666').parent.text
page.find('#question_answer_666').inspect
exit
page
page.html
exit
current
exit
medium
medium.url
subject
subject.url
subject.medium_url
medium
exit
mime_type
mime_type.content_type
mime_type.class
extension
s3_key
File.extname(s3_key)
raw_type
@mime_type
MIME::Types.type_for(raw_url)
MIME::Types.type_for(raw_url).first
MIME::Types.type_for(raw_url).count
MIME::Types.type_for(raw_url)[1]
MIME::Types.type_for(raw_url)[1].content_type
MIME::Types.type_for(raw_url)[0].content_type
MIME::Types.type_for(raw_url)[0].raw_type
MIME::Types.type_for(raw_url)[0].raw_media_type
MIME::Types.type_for(raw_url)[1].raw_media_type
MIME::Types.type_for(raw_url).find(raw_media_type: 'video')
MIME::Types.type_for(raw_url).find(raw_media_type: 'video').first
MIME::Types.type_for(raw_url).find(raw_media_type: 'video').content_type
MIME::Types.type_for(raw_url).find(raw_media_type: 'video').first.content_type
MIME::Types.type_for(raw_url).class
MIME::Types.type_for(raw_url).select(raw_media_type: 'video')
MIME::Types.type_for(raw_url).select{ |e| e.raw_media_type == 'video }
MIME::Types.type_for(raw_url).select{ |e| e.raw_media_type == 'video' }
mime_type.content_type
MIME::Types.type_for(raw_url).select{ |e| e.raw_media_type == 'video' }
MIME::Types.type_for(raw_url).select{ |e| e.raw_media_type == 'video' }.content_type
MIME::Types.type_for(raw_url).select{ |e| e.raw_media_type == 'video' }.first
MIME::Types.type_for(raw_url).select{ |e| e.raw_media_type == 'video' }.first.content_type
raw_url
raw_url.include? 'webm'
exit!
survey.id
next
exit
next
options
options[:appended_question_attributes]
options[:appended_question_attributes].present?
options
next
generate_appended_question(context, counter)
options[:appended_question_attributes].try(:[], :options).try(:[], :id)
up
next
question_generator.label
options[:appended_question_attributes].try(:[], :options).try(:[], :id)
return unless survey.target.default_language_code
finder = TranslationFinder.new(survey.target.default_language_code)
extractor = Services::Admin::SurveyTranslationsExtractor.new(survey).call
[ questions, generate_overrides(context) ]
up
[ generated_questions, overrides ]
next
generated_questions
overrides
next
[ generated_questions, overrides ]
up
survey
survey.questionnaire
survey.questionnaire.flatten
survey.questionnaire.flatten.last
survey.questionnaire.flatten.last.class
survey.questionnaire.flatten.last.content
survey.questionnaire.flatten.last.label
survey.questionnaire.flatten.last.label.class
survey.questionnaire.flatten.last.content
survey.questionnaire.flatten.last.content.class
survey.questionnaire.flatten.last.content.keys
exit
keys
up
keys
up
labels
default
up
content
up
translated_content
keys
up
default
up
content
down
labels
default
labels
up
keys
options
up
keys
options
up
translation_root
label
translation_leaf
parent_labels
keys
options
keys
options
survey.questionnaire.flatten.last.content.keys
survey.questionnaire.flatten.last.content
survey.questionnaire.flatten.last.content.options
survey.questionnaire.flatten.last.content
expect(survey.questionnaire.flatten.last.content.keys).to include(:adnow_brand_exposure_666)
translatable_content = survey.questionnaire.flatten.last.content
translatable_content.options
translatable_content.options[:default]
exti
exit
Order.last
o = Order.last
o.product_setups.first
class Hash
  def difference(other)
    reject do |k,v|
      other.has_key?(k) && other[k] == v
    end
  end
end
expected_data.merge(common_data)
expected_data.merge(common_data).differece(adapted_data)
expected_data.merge(common_data).difference(adapted_data)
adapted_data.difference(expected_data.merge(common_data))
expect(adapted_data).to eq(expected_data.merge(common_data))
adapted_data.difference(expected_data.merge(common_data))
expect(adapted_data).to eq(expected_data.merge(common_data))
adapted_data.difference(expected_data.merge(common_data))
adapted_data[:survey_components]
expect(adapted_data).to eq(expected_data.merge(common_data))
exit
exit
Order.last
o
order = Order.last
source = { order: order }
pipe = Pipes::StartProcessEyeSquareProjectPipeline.new(source)
pipe = CheckoutSystem::OrderProcessing::Pipelines::ProcessOrderPipeline::Pipes::StartProcessEyeSquareProjectPipeline.new(source)
CheckoutSystem::OrderProcessing::Pipelines::ProcessOrderPipeline::Pipes::StartProcessEyeSquareProjectPipeline
CheckoutSystem::OrderProcessing::Pipes::StartProcessEyeSquareProjectPipeline
CheckoutSystem::OrderProcessing::Pipelines::Pipes::StartProcessEyeSquareProjectPipeline
pipe = CheckoutSystem::OrderProcessing::Pipelines::Pipes::StartProcessEyeSquareProjectPipeline.new(source)
pipe.execute
source
order
order.task_options
source.task_options
order.pending?
order.eye_square_project
Pipes::EyeSquare::UpdateLocalProjectAdsRedirectUrl
CheckoutSystem::OrderProcessing::Pipelines::Pipes::EyeSquare::UpdateLocalProjectAdsRedirectUrl
pipe = CheckoutSystem::OrderProcessing::Pipelines::Pipes::EyeSquare::UpdateLocalProjectAdsRedirectUrl.new(order.eye_square_project)
pipe.method(:client)
pipe.method(:client).source_location
order
order.create_eye_square_project
uare_project(
  project_id: eyesquare_response['project_id'],
  task_options: eyesquare_request_data[:task],
  client_name: client_name,
  sdk_project: true,
  eye_square_ads_attributes: eye_square_ads_attributes(eyesquare_response['ads'])
)
project = order.create_eye_square_project(
  project_id: eyesquare_response['project_id'],
  task_options: eyesquare_request_data[:task],
  client_name: client_name,
  sdk_project: true,
  eye_square_ads_attributes: eye_square_ads_attributes(eyesquare_response['ads'])
)
["fuck", "you"] === "fuck"
["fuck", "you"] === "you"
order.eye_square_project
order.eye_square_project.class
order.eye_square_project.task_options
order.eye_square_project.eye_square_ads
SurveyComponentModels::AttDigitalCreativeTest::InstagramImageComponent.last
SurveyComponentModels::AttDigitalCreativeTest::InstagramImageComponent.last.main_medium
exit!
rspec --format documentation spec/lib/mongo_models/checkout_system_models/eye_square_ads/instagram_ad_spec.rb:24
exit
EyeSquareAdapter.adapt_request_keys(unadapted_eye_square_options)
unadapted_eye_square_options
unadapted_eye_square_options.class
unadapted_eye_square_options.method(:deep_transform)
unadapted_eye_square_options.method(:deep_transform_keys)
unadapted_eye_square_options.method(:deep_transform_keys).source_location
exit!
unadapted_eye_square_options
a = 1
4.times.map{ 1 }
4.times.map{ [1,2,3,4] }
4.times.map{ [1,2,3,4] }.flatten
questions = _
questions.shuffle
150 / 5
times = questions.size
exit
10 / 3
10 / 6
20 / 6
20 / 7
exit
results
result
aa = [1,2]
bb = [3,4,5]
res_a = 150.times.map{ aa }.flatten.shuffle
res_b = 150.times.map{ bb }.flatten.shuffle
final = 150.times.map{ [:res_a, :res_b, 6] }.flatten.shuffle
result = final.times.map{ |el| el.is_a?(Symbol) ? eval(el.to_s).send(:shift) : el }
result = final.map{ |el| el.is_a?(Symbol) ? eval(el.to_s).send(:shift) : el }
res=Hash[result.group_by {|x| x}.map {|k,v| [k,v.count]}]
result.count
res_a = 150.times.map{ aa }.flatten.shuffle
res_b = 150.times.map{ bb }.flatten.shuffle
final.count
final = 150.times.map{ [:res_a, :res_b, 6] }.flatten.shuffle
final.count
150/3
final = 50.times.map{ [:res_a, :res_b, 6] }.flatten.shuffle
result = final.map{ |el| el.is_a?(Symbol) ? eval(el.to_s).send(:shift) : el }
res=Hash[result.group_by {|x| x}.map {|k,v| [k,v.count]}]
res_a = 150.times.map{ aa }.flatten.shuffle
res_b = 150.times.map{ bb }.flatten.shuffle
result = final.map{ |el| el.is_a?(Symbol) ? eval(el.to_s).send(:sample) : el }
res=Hash[result.group_by {|x| x}.map {|k,v| [k,v.count]}]
result = final.map{ |el| el.is_a?(Symbol) ? eval(el.to_s).send(:sample) : el }
res=Hash[result.group_by {|x| x}.map {|k,v| [k,v.count]}]
res=Hash[result.group_by {|x| x}.map {|k,v| [k,v.count]}].sort
res=Hash[result.group_by {|x| x}.map {|k,v| [k,v.count]}]
jjj
survey = { created_at: 18973981273 }
respondents = Array(1..150)
sequence1 = [3,4,5]
sequence2 = [7,8,9]
all_questions = [1,2,sequence1,6,sequence2]
sequence1_seed = Random.new(survey[:created_at])
sequence2_seed = Random.new(survey[:created_at]*2) # 2 stands for index of sequence inside of a survey
uence1 = [3,4,5]
sequence2 = [7,8,9]
all_questions = [1,2,sequence1,6,sequence2]
sequence1_seed = Random.new(survey[:created_at])
sequence2_seed = Random.new(survey[:created_at]*2) # 2 stands for index of sequence inside of a survey
randomized_sequence1 = (respondents.size/sequence1.size+1).times.map{ sequence1 }.flatten.shuffle(random: sequence1_seed)
randomized_sequence2 = (respondents.size/sequence2.size+1).times.map{ sequence2 }.flatten.shuffle(random: sequence2_seed)
PP.pp randomized_sequence1
res=Hash[randomized_sequence1.group_by {|x| x}.map {|k,v| [k,v.count]}]
respondents.each do |respondent_id|
  result[respondent_id] = []
  all_questions.flatten.each do |question_id|
    result[respondent_id] << question_id && next unless [sequence1, sequence2].flatten.include? question_id
    if randomized_sequence1[respondent_id] == question_id || randomized_sequence2[respondent_id] == question_id
      result[respondent_id] << question_id
    end
  end
end
result = {}
### SURVEY ROUTING
respondents.each do |respondent_id|
  result[respondent_id] = []
  all_questions.flatten.each do |question_id|
    result[respondent_id] << question_id && next unless [sequence1, sequence2].flatten.include? question_id
kk### SURVEY ROUTING
respondents.each do |respondent_id|
  result[respondent_id] = []
  all_questions.flatten.each do |question_id|
    result[respondent_id] << question_id && next unless [sequence1, sequence2].flatten.include? question_id
    if randomized_sequence1[respondent_id] == question_id || randomized_sequence2[respondent_id] == question_id
      result[respondent_id] << question_id
    end
  end
end
###
all_questions.size
all_questions.length
all_questions
result.length
res=Hash[result.group_by {|x| x}.map {|k,v| [k,v.count]}]
result
counts = result.values.flatten.inject(Hash.new(0)){ |total, q| total[q]+=1; total }
puts "Responses per respondent:"
result.each{ |respondent_id, questions_seen| puts "#{questions_seen}" }
puts "\nSequence #1"
sequence1.each{ |question| puts "Question #{question} has been seen #{counts[question]} times" }
puts "\nSequence #2"
sequence2.each{ |question| puts "Question #{question} has been seen #{counts[question]} times" }
survey = { created_at: 18973981273 }
respondents = Array(1..150)
sequence1 = [3,4,5]
sequence2 = [7,8]
all_questions = [1,2,sequence1,6,sequence2]
sequence1_seed = Random.new(survey[:created_at])
sequence2_seed = Random.new(survey[:created_at]*2) # 2 stands for index of sequence inside of a survey
jrandomized_sequence1 = (respondents.size/sequence1.size+1).times.map{ sequence1 }.flatten.shuffle(random: sequence1_seed)
randomized_sequence2 = (respondents.size/sequence2.size+1).times.map{ sequence2 }.flatten.shuffle(random: sequence2_seed)
result = {}
respondents.each do |respondent_id|
  result[respondent_id] = []
  all_questions.flatten.each do |question_id|
    result[respondent_id] << question_id && next unless [sequence1, sequence2].flatten.include? question_id
    if randomized_sequence1[respondent_id] == question_id || randomized_sequence2[respondent_id] == question_id
      result[respondent_id] << question_id
    end
  end
end
counts = result.values.flatten.inject(Hash.new(0)){ |total, q| total[q]+=1; total }
puts "Responses per respondent:"
result.each{ |respondent_id, questions_seen| puts "#{questions_seen}" }
puts "\nSequence #1"
sequence1.each{ |question| puts "Question #{question} has been seen #{counts[question]} times" }
puts "\nSequence #2"
sequence2.each{ |question| puts "Question #{question} has been seen #{counts[question]} times" }
result = {}
all_questions
respondents
result
randomized_sequence1
((2 ** (8 * 8 - 2) * - 1)
  ((2 ** (8 * 8 - 2)  - 1)
    ((2 ** (8 * 8 - 2)) * - 1)
((2 ** (8 * 8 - 2)) * - 1)
((2 ** (8 * 8 - 2)) * - 1).class
((2 ** (8 * 8 - 2)) * 1).class
-1.class
((2 ** (8 * 8 -2)) * 1)
_ * -1
_.class
((2 ** (8 * 8 -2)) * - 1) -1
_.class
8 * 8 
_ - 2
machine_bytes = ['foo'].pack('p').size
machine_bits = machine_bytes * 8
machine_max_signed = 2**(machine_bits-1) - 1
machine_max_unsigned = 2**machine_bits - 1
0.size
exit
piss = Product.find(39)
piss.sdk_enabled = true
piss.save!
exit
product_setup
exit
product_setup
exit
service_class
args
exit!
{ hi: 1 }.merge({hi: 2})
exit
survey_params
exit
request_params
exit
data_collector_request_body
expected = _
request_params
request_params[:body]
request_params.class
build_request_params(parameters, request_method)
build_request_params(parameters, request_method)[:body]
exi
exit
data_collector_request_body = data_collector_request_body.sort_by{ |k,v| k.to_s }
data_collector_request_body
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9224)
survey.finished?
survey.finished_at
survey.closed
survey.closed?
SurveyResponse::COMPLETE_TIMEOUT
SurveyResponse::COMPLETE_TIMEOUT.ago
Time.now
Time.now + 10.minutes
survey = survey_repo.find(9225)
survey.finished?
survey.finished_at
survey.finished_at = nil
survey_repo.update(survey)
survey
survey.finished_at
survey.finished_at = nil
survey_repo.update(survey)
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9225)
survey.finished?
Jobs::BatchDispatchResponses
Jobs::BatchDispatchResponses.perform(survey.id, true)
survey_repo
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9226)
survey.finished_at
Jobs::BatchDispatchResponses.perform(survey.id, true)
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9226)
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9228)
Jobs::BatchDispatchResponses.perform(survey.id, true)
dat
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9229)
ur = InsightOutServices::UpdateReport.new(survey.id)
ur.send(:responses)
ur.send(:responses).count
ur.send(:responses)
ur.send(:responses).count
survey.order(survey_repository: survey_repo).surveys
order_surveys = survey.order(survey_repository: survey_repo).surveys
def survey_response_repo
  @survey_response_repo ||= Repositories::SurveyResponseRepository.new
end
survey_responses = survey_response_repo.ready_for_sending(survey)
survey_reposonse.count
survey_reposonses.count
survey_responses.count
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9229)
insight_out_communication_service = InsightOutServices::InsightOutCommunicationService.new(survey)
insight_out_communication_service.complete_report
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9229)
Jobs::BatchDispatchResponses.perform(survey.id, true)
survey_response
survey_responses
survey_responses.count
Jobs::BatchDispatchResponses.perform(survey.id, true)
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9229)
Jobs::BatchDispatchResponses.perform(survey.id, true)
survey_responses
survey_responses.count
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9230)
Jobs::BatchDispatchResponses.perform(survey.id, true)
survey_responses
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9230)
Jobs::BatchDispatchResponses.perform(survey.id, true)
exi
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9230)
Jobs::BatchDispatchResponses.perform(survey.id, true)
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9230)
Jobs::BatchDispatchResponses.perform(survey.id, true)
ready?
survey_response_status_check_service.ready_to_update_report?
survey.sent_at = Time.now
survey_repo.update(survey)
Jobs::BatchDispatchResponses.perform(survey.id, true)
request.response
result
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(9231)
survey.sent_at = Time.now
survey_repo.update(survey)
Jobs::BatchDispatchResponses.perform(survey.id, true)
survey_responses.count
result
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repository.find(survey_id)
survey = survey_repo.find(9232)
Jobs::BatchDispatchResponses.perform(survey.id, true)
exit
DatabaseModels::Survey.last
dbsu = _
dbsu.report_id
dbsu.external_report_id
!nil
exit
def test
  result = false
end
test
def test
  result = true
end
test
exit
dbs = DatabaseModels::Survey.last
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find(dbs.id)
drg = Services::DummyResponseGenerator.new(_)
drg = Services::DummyResponseGenerator.new(survey)
Services
Services::
DummyResponsesGenerator
Services::DummyResponsesGenerator
drg = Services::DummyResponsesGenerator survey
drg = Services::DummyResponsesGenerator.new(survey)
drg.call(size: 149)
survey.id
dummy_responses = drg.call(size: 149)
survey_response_repository.bulk_insert(dummy_responses)
survey_response_repository = options.fetch(:survey_response_repository) { Repositories::SurveyResponseRepository.new }
options = {}
survey_response_repository = options.fetch(:survey_response_repository) { Repositories::SurveyResponseRepository.new }
survey_response_repository.bulk_insert(dummy_responses)
dummy_responses = drg.call(size: 5)
survey_response_repository.bulk_insert(dummy_responses)
survey.id
survey = survey_repo.find 9237
drg = Services::DummyResponsesGenerator.new(survey)
dummy_responses = drg.call(size: 5)
survey_response_repository.bulk_insert(dummy_responses)
survey = survey_repo.find 9238
drg = Services::DummyResponsesGenerator.new(survey)
dummy_responses = drg.call(size: 10)
survey_response_repository.bulk_insert(dummy_responses)
survey.order.all_surveys_finished?
survey_response_repo = options.fetch(:survey_response_repo) { Repositories::SurveyResponseRepository.new }
def finished_responses_count
  survey_response_repo.finished_count(survey)
end
survey.target.enough_responses?(finished_responses_count, false)
survey_response_repo.finished_count(survey)
survey.target.enough_responses?(finished_responses_count, false)
survey.target.enough_responses?(10, false)
survey = survey_repo.find 9239
drg = Services::DummyResponsesGenerator.new(survey)
dummy_responses = drg.call(size: 10)
survey_response_repository.bulk_insert(dummy_responses)
exit
question_response.duration_milliseconds
up
question_response
survey_response_repo = Repositories::SurveyResponseRepository.new
dbserve = DatabaseModels::Survey.last
dbsrr = DatabaseModels::SurveyResponse.last
survey_repo = Repositories::SurveyRepository.new; survey = survey_repo.find(8730)
survey = survey_repo.find dbsrr.survey_id
survey_response_repo.ready_for_sending(survey)
survey_response_repo.ready_for_sending(survey, dbsrr.id)
survey_response_repo.ready_for_sending(survey, {survey_response_id: dbsrr.id })
dbsrr
exit
402
exit
DatabaseModels::Survey.last
dbs = _
Repositories::SurveyRepository.find dbs.id
Repositories::SurveyRepository.new.find dbs.id
survey = _
exit
File.open
exit
generator = Services::DummyResponsesGenerator.new(survey)
survey
sr = Repositories::SurveyRepository.new
sr.find 9245
survey = _
generator = Services::DummyResponsesGenerator.new(survey)
dummy_responses = generator.call
survey_response_repository.bulk_insert(dummy_responses)
dummy_responses = generator.call({ size: 12 })
options = { }
survey_repository = options.fetch(:survey_repository) { Repositories::SurveyRepository.new }
generator = Services::DummyResponsesGenerator.new(survey)
dummy_responses = generator.call
survey_response_repository.bulk_insert(dummy_responses)
survey_response_repository
survey_response_repository = options.fetch(:survey_response_repository) { Repositories::SurveyResponseRepository.new }
generator = Services::DummyResponsesGenerator.new(survey)
dummy_responses = generator.call
survey_response_repository.bulk_insert(dummy_responses)
def self.perform(survey_ids)
  survey_ids.each do |survey_id|
    survey = Repositories::SurveyRepository.new.find(survey_id)
    Services::DummyResponsesCreator.new(survey.id).call
    InsightOutServices::CreateReport.new(survey.id, queue_remaining_responses: false).call unless survey.sent?
    # Has to be set as panel size - 20, because BatchDispatchRequests has to at least send 1 respondent otherwise the request
    # is discarded by IO and a 400 is returned. This is a hack, hopefully we can remove this when IO clean up their bit.
    InsightOutServices::UpdateReport.new(survey.id, response_limit: survey.target.panel_size - 20).call
  end
end
InsightOutServices::CreateReport.new(survey.id, queue_remaining_responses: false).call
srr
survey_response_repository.ready_for_sending(survey)
def order_surveys(survey)
  survey.order(survey_repository: survey_repo).surveys
end
order_surveys.each_with_index do |cell_survey, cell_survey_index|
  InsightOutServices::UpdateReport.new(cell_survey.id, get_options).call
end
order_surveys.each_with_index do |cell_survey, cell_survey_index|
  InsightOutServices::UpdateReport.new(cell_survey.id, get_options).call
end
order_surveys = order_surveys(survey)
order_surveys.each_with_index do |cell_survey, cell_survey_index|
  InsightOutServices::UpdateReport.new(cell_survey.id, get_options).call
end
order_surveys = order_surveys(survey)
def survey_repo
  @survey_repo ||= Repositories::SurveyRepository.new
end
order_surveys = order_surveys(survey)
_count
_.count
gbl
survey_response_repository.ready_for_sending(survey)
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 2390
survey.method(:gender_id)
dbs = DatabaseModels::Survey.last
dbs.gender_id
dbs.method(:gender_id).source_location
survey.target.gender_id
exit
next
is_zip_file?(file_param)
next
step
next
main_file
additional_files
additional_file_directory_paths
step
up
step
up
step
next
medium
next
up
next
medium
medium.to_json
medium.image_thumbnail
medium.class
exit
object.file.class
object.image_thumbnail
object.file.image_thumbnail
object.file.image_thumbnail.class
object.file.class
object.method(:file).source_location
exit!
medium.class
medium.object
medium
j
medium.object.class
medium.object.file
medium.object.file.image
medium.object.file
medium.object.file.image_thumbnail
medium.object.file.image_thumbnail.url
exit!
MediaManipulator::Manipulators::LiveImagesManipulator.new.get_dynamic_thumbnail(object)
MediaManipulator::Manipulators::LiveImagesManipulator.new.get_thumbnail(object)
mm = MediaManipulator::Manipulators::LiveImagesManipulator.new
mm.get_thumbnail(object)
mm.get_thumbnail(self(
mm.get_thumbnail(self)
exit!
MediaManipulator::Manipulators::LiveImagesManipulator.new.get_thumbnail(object)
OpenStruct.new(object)
object.user_file
object.file_path
object.image
object.image.path
object.class
object.file.class
object.file.image
object.file.
object.file.class
object.file.resize_to_fit(200, 600)
object.file.resize_to_fit(200, 200)
object.file.resize_to_fi;;(200, 200)
object.file.resize_to_fill(200, 200)
object.file.resize_to_fill(200, 300)
object.file.resize_to_fill(200, 400)
object.file.resize_to_fill(500, 400)
exit!
object.file.resize_to_fill(500, 400)
object.file.resize_to_fit(500, 400)
object.file.resize_to_fill(500, 400)
object.file.resize_and_pad(500, 400)
object.file.resize_and_pad(500, 900)
object.file.resize_to_limit(500, 900)
object.file.resize_to_limit(200,200)
object.file.resize_to_fit(200,200)
object.file.resize_to_fill(200,200)
object.file.resize_to_fit(200,200)
object.file.resize_to_limit(200,200)
object.file
object.file.resize_to_limit(200,200)
object.file.resize_to_limit(200,400)
object.file.resize_to_limit(400,200)
object.file.resize_to_fill(400,200)
DatabaseModels::Gender.all
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey = survey_repo.find 2390
survey = survey_repo.find 9458
survey_response_repo.finished_count survey
stuff = survey_response_repo.send(:finished_records_for_survey, survey)
backend = Repositories::Backends::Database::SurveyResponseBackend.new
stuff = backend.send(:finished_records_for_survey, survey)
stuff.class
stuff.count
survey = survey_repo.find 9530
survey_response_repo.finished_count survey
survey_repo = Repositories::SurveyRepository.new
survey_repo.find 9650
survey = )
survey = _
survey.finished_at
survey = survey_repo.find 9650
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_response_repo.finished_count(survey)
survey.target.enough_responses?(160, false)
survey = survey_repo.find 9666
survey.finished_at
survey = survey_repo.find 9650
survey.finished_at
survey.target.panel_size
survey = survey_repo.find 9639
survey.finished_at
survey_response_repo.finished_count(survey)
survey.target.enough_responses?(91, fale)
survey.target.enough_responses?(91, false)
survey.target.enough_responses?(160, false)
survey.target.enough_responses?(159, false)
survey.target.enough_responses?(148, false)
survey.id
survey = survey_repo.find 9650
survey.target
survey.order.all_surveys_finished?
DatabaseModels::SurveyResponse.where(survey_id: 9650, quota_failure_cause: 'total_quota_full')
DatabaseModels::SurveyResponse.where(survey_id: 9650)
_.count
160 + 120 +32
DatabaseModels::SurveyResponse.where(survey_id: 9650,
)
DatabaseModels::SurveyResponse
DatabaseModels::SurveyResponse.where(survey_id: 9650, quota_failure_cause: 'total_quota_full')
DatabaseModels::SurveyResponse.where(quota_failure_cause: 'total_quota_full').size
DatabaseModels::SurveyResponse.where(survey_id: 9650, quota_failure_cause: 'total_quota_full')
DatabaseModels::SurveyResponse.where(survey_id: 9650).map(:quota_failure_cause)
DatabaseModels::SurveyResponse.where(survey_id: 9650).map(&:quota_failure_cause)
DatabaseModels::SurveyResponse.where("survey_id = ? AND quota_failure_cause IS NULL", 9650).size
DatabaseModels::SurveyResponse.where("survey_id = ? AND quota_failure_cause IS NULL AND completed_at IS NOT NULL", 9650).size
survey.id
survey_response_repo.finished_count(survey)
DatabaseModels::SurveyResponse.where("survey_id = ? AND quota_failure_cause IS NULL AND end_time IS NOT NULL", 9650).size
x = DatabaseModels::SurveyResponse.where("survey_id = ? AND quota_failure_cause IS NULL AND end_time IS NOT NULL", 9650).size
survey.target.enough_responses?(survey_response_repo.finished_count(survey), false)
survey.id
survey.finished_A
survey.finished_at
x = DatabaseModels::SurveyResponse.where("survey_id = ? AND quota_failure_cause IS NULL AND end_time IS NOT NULL", 9650).size
survey.finished_at
survey.target.enough_responses?(survey_response_repo.finished_count(survey), false)
survey.id
exit
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey = survey_repo.find 9650
survey_response_repo.finished_count(survey(
survey_response_repo.finished_count(survey)
survey
survey_response_repo.finished_count(survey)
x = DatabaseModels::SurveyResponse.where("survey_id = ? AND quota_failure_cause IS NULL AND end_time IS NOT NULL", 9650).size
x
exit
survey
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey = survey_repo.find 9650
survey_response_repo.finished_count(survey)
survey_response_repo.finished_count(survey).where
survey_repo = Repositories::SurveyRepository.new
survey_response_repo.finished_count(survey).where
survey_response_repo = Repositories::SurveyResponseRepository.new
survey = survey_repo.find 9650
DatabaseModels::SurveyResponse.where(survey_id: survey.id)
raise 'fuck u;
'
raise 'fuck u'
exit
file
file.class
object.file
object.file.path
medium.to_json
survey_repo = Repositories::SurveyRepository.new
survey = sureyrepo.find 9668
survey = survey)repo.find 9668
survey = survey_repo.find 9668
survey = survey_repo.find 9650
hi = { hi: "there" }
hi.fetch(:hi, "lol")
exit
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
sr = DatabaseModels::SurveyResponse.last
DatabaseModels::QuestionResponse.last
survey_response_repo.finished(survey)
survey
survey = survey_repo.find 7564
survey_response_repo.finished(survey)
ProjectSetup::ProductSetup
ProjectSetup::ProductSetup.where(order_id: 210217)
DatabaseModels::SurveyResponse.where(survey_id: survey.id).can_be_exported
DatabaseModels::SurveyResponse.where(survey_id: survey.id).can_be_exported.count
survey.id
DatabaseModels::SurveyResponse.where(survey_id: survey.id).exportable.count
DatabaseModels::SurveyResponse.last
number = 12345678
number.to_s
number_s = _
number_s.slice[-3]
number_s.slice[-3,0]
number_s.slice(0, -30
number_s.slice(0, -3)
exit
exit!
parse_args_to_hash
args
parse_args_to_hash(args)
args
exit!
Product.where(slug_or_id: :tyson-foods-idea-and-flavor-screener)
Product.where(slug_or_id: 'tyson-foods-idea-and-flavor-screener')
Product.last
Product.where(slug: 'tyson-foods-idea-and-flavor-screener')
tyson = _
tyson.sdk_enabled
tyson = tyson.first
tyson.sdk_enabled
tyson.sdk_enabled = true
tyson.save
tyson.save!
exit!
{}.fetch(:lol)
{}.fetch(:lol, false)
hash = { }
hash[:force]
exit
user = SystemUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
user.add_role :super_admin
user.save!
exit
user = SystemUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
user.add_role :super_admin
user.save!
{{{
      user = AdminUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
user.addrole :super_admin
user.save!
}}}
user = AdminUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
user.addrole :super_admin
user.add_role :super_admin
user.save!
exit
exit
Customer.last
denesh = _
denesh.confirmed_at = Time.now
denesh.save!
user = AdminUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
user.add_role :super_admin
user.save!
DatabaseModels::Order
DatabaseModels::Order.where(id: 205227)
DatabaseModels::Order.last
DatabaseModels::Order
exit
DatabaseModels::Survey.where(external_order_id: 205227)
DatabaseModels::Survey.where(external_order_id > 205227)
DatabaseModels::Survey.where("external_order_id > ?", 205227)
DatabaseModels::Survey.where("external_order_id > ?", 205227).destroy_all
DatabaseModels::Survey.where("external_order_id > ?", 205226).destroy_all
DatabaseModels::Survey.where("external_order_id > ?", 205226)
DatabaseModels::Survey.destroy_all("external_order_id > ?", 205226)
DatabaseModels::Survey.("external_order_id > ?", 205226).destroy
DatabaseModels::Survey.where("external_order_id > ?", 205226).destroy
DatabaseModels::Survey.where("external_order_id > ?", 205226)
DatabaseModels::Survey.where("external_order_id > ?", 205226).count
exit
DatabaseModels::Survey.where("external_order_id > ?", 205226)
DatabaseModels::Survey.where("external_order_id > ?", 205226).count
DatabaseModels::Survey.where("external_order_id > ?", 205226).destroy_all
DatabaseModels::Survey.where("external_order_id > ?", 205226).destroy_all !
DatabaseModels::Survey.where("external_order_id > ?", 205226).destroy_all
DatabaseModels::Survey.where("external_order_id > ?", 205226).destroy_all!
hash = { hi: "there" }
hash.delete(:hi) { "2" }
hash.delete(:fuck)
hash[:fuck]
hash.select{ |k,v| k == :fuck }
exit
args
survey.order.all_surveys_can_be_set_as_complete? || args.fetch(:force_complete, false)
eit
exit
ProjectSetup::ProductSetup
ProjectSetup::ProductSetup.last
ProjectSetup::ProductSetup.last.product
ProjectSetup::ProductSetup.last.destroy
ProjectSetup::ProductSetup.last
exit
And I click on button "Pay for this project"
And I click on link "Pay for this project"
exit!
execute_script %Q[ $("textarea[ng-model='configurationContext[configurationElement.name]']").clear()
]
execute_script %Q[ $("textarea[ng-model='configurationContext[configurationElement.name]']").value = ""; ]
execute_script %Q[ $("#survey_introduction_text").value = ""; ]
execute_script %Q[ $("#survey_introduction_text").value = "" ]
execute_script %Q[ $("#survey_introduction_text").clear() ]
execute_script %Q[ $("#survey_introduction_text").value = "fafaf" ]
element
fill_in('#survey_introduction_text', with: "")
fill_in('textarea', with: "")
fill_in('textarea#survey_introduction_text', with: "")
fill_in('survey_introduction_text', with: "")
fill_in('textarea[ng-model="configurationContext[configurationElement.name]"]', "hi")
fill_in('textarea[ng-model="configurationContext[configurationElement.name]"]', with: "hi")
fill_in('survey_introduction_text', with: "hi")
exit!
exit
page.enter_text_in_input("", "input[ng-model='orderDetails.title']")
page
page.enter_text_in_input('lol', "input[ng-model='orderDetails.title']")
find('text')
find('input[ng-model="orderDetails.title"]')
find('input[ng-model="orderDetails.title"]').clear
find('input[ng-model="orderDetails.title"]').set ''
exit!
exit
next
text
label
exit
next
exit
Order.last
exit
exit!
Then I click on button "Show details"
label = "Show details"
find("button", text: Regexp.new(Regexp.escape(label.upcase), "i"), match: :first)
execute_script %Q[ $('button:contains(#{label.to_json}):first').click() ]
find("button", text: Regexp.new(Regexp.escape(label.upcase), "i"), match: :first).click
visit('/project_setup/favor-it/configuration')
find("button", text: Regexp.new(Regexp.escape(label.upcase), "i"), match: :first).click
label = "Edit & place order"
find("button", text: Regexp.new(Regexp.escape(label.upcase), "i"), match: :first).click
label = "Show details"
find("button", text: Regexp.new(Regexp.escape(label.upcase), "i"), match: :first)
execute_script %Q[ $('button:contains(#{label.to_json}):first').click() ]
label
Then(/^I click on button "([^"]*)"$/) do |label|
  PageObjects::Page.wait_and_eval do |page|
    find("button", text: Regexp.new(Regexp.escape(label.upcase), "i"), match: :first).click
    #execute_script %Q[ $('button:contains(#{label.to_json}):first').click() ]
  end
end
find("button", text: Regexp.new(Regexp.escape(label.upcase), "i"), match: :first).click
label = "Edit & place order"
find("button", text: Regexp.new(Regexp.escape(label.upcase), "i"), match: :first).click
exit
element
page_from_questionnaire.class
page_from_questionnaire.elements
page_from_questionnaire.display_condition
page_from_questionnaire.send(:display_condition)
page_from_questionnaire.send(:display_condition, survey, survey_reponse)
page_from_questionnaire.send(:display_condition, survey, survey_response)
_.call
dc = page_from_questionnaire.send(:display_condition, survey, survey_response)
dc.block
dc.sequence
page_from_questionnaire.series_component
page_from_questionnaire.elements
page_from_questionnaire.elements.first
page_from_questionnaire.elements.first.question
page_from_questionnaire.elements.first.question.method(:visible_for?)
page_from_questionnaire.elements.first.question.method(:visible_for?).source_location
page_from_questionnaire.elements.first.question.options
options
page_from_questionnaire.elements.first.question.options[:display_condition_block]
page_from_questionnaire.elements.first.question.options[:display_condition_block].to_source
require "parse_tree"
exit
block
display_in_sequence?
next
object.class
object.content
object.translations
object.translations.to_a
object.options
up
next
up
exit1
survey_repo = Repositories::SurveyRepository.new
survey_repo.find 9669
survey = _
survey.blueprint_id = 116
survey_repo.update survey
build_before_start_instruction_text
default_before_start_instruction_text
default_before_start_instruction_text.class
default_before_start_instruction_text.to_s
build_before_start_instruction_text.to_s
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9669
@translations = Services::Admin::SurveyTranslationsExtractor.new(@survey).call
@translations = Services::Admin::SurveyTranslationsExtractor.new(survey).call
object.content
object.translations
up
next
up
next
step
questionnaire.traverse_questions
questionnaire.traverse_questions.first
questionnaire.traverse_questions.first.class
questionnaire.traverse_questions.first.label
questionnaire.traverse_questions.each { |q| puts q.label }
next
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9669
@translations = Services::Admin::SurveyTranslationsExtractor.new(survey).call
element
exit
element
exit
element
page
exit
element
element.translations
caller.reject{ |x| x.include?('gem') }
element
element.label
element.template_name
exit
element
element.template_name
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9669
@translations = Services::Admin::SurveyTranslationsExtractor.new(survey).call
caller.reject{ |x| x.include?('gem') }
options
@before_start_instruction_text
up
up\
up
@options
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9669
@translations = Services::Admin::SurveyTranslationsExtractor.new(survey).call
@options
questionnaire.flatten_pages
questionnaire.flatten_pages[1].elements[1]
questionnaire.flatten_pages[1].elements[1].translations
exit
options
exit
@options
@options[:translations][1]
@options[:translations][1].to_s
@options[:translations][1]
@options
exit
@options
exit
@options
object.options
get_translation(:before_start_instruction_text)
object.options[:before_start_instruction_text]
object.options[:translations][:before_start_instruction_text]
object.options[:translations][:before_start_instruction_text].to_s
exit
@options
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
context
opts
self
@options
@options[:translations][:before_start_instruction_text]
@options[:translations][:before_start_instruction_text].to_s
TranslatableContentComposer.new(self, context, opts).compose.retrieve_from_translation_backend(context, opts)
key
alias_key
finder.find(key, alias_key)
key
DatabaseModels::Translation.find_by(key: key, lang_code: lang)
lang = "en_US"
DatabaseModels::Translation.find_by(key: key, lang_code: lang)
@options
@options[:translations][:before_start_instruction_text].to_s
@lang_code
language_chain
@options[:translations][:before_start_instruction_text].to_s
exit
@options[:translations][:before_start_instruction_text].to_s
get_translation(:before_start_instruction_text)
@options
object.options
object.options[:translations][:before_start_instruction_text].to_s
question.class
question.object.class
exit
options
caller.reject{ |x| x.include?('gem') }
up
element
element.class
exit
optins
options
caller.reject{ |x| x.include?('gem') }
up
options
generate_options(context).merge(overrides)
context
overrides
caller.reject{ |x| x.include?('gem') }
exit
question.class
question.object.class
exit
options
template
question_filter_options
caller.reject{ |x| x.include?('gem') }
question.options
up
@question_builder.class
caller.reject{ |x| x.include?('gem') }
options
up
option
options
up
@options
options
question
question.options
options
question
question.options
caller.reject{ |x| x.include?('gem') }
label
options
label
options
elements
caller.reject{ |x| x.include?('gem') }
up
down
@element_builders
@label
options
build_element
build_elements
down
options
@elements
@options
@elements[0]
@elements[0].options
@elements[0].class
options
up
options
question_or_generator
question_or_generator.class
up
element.question.class
@translations
exit
@translations
optional_translations
options
exit
options
@translations
build_translations
bank = _
bank[:before_start_instruction_text]
bank[:before_start_instruction_text].to_s
build_options
@translations
build_translations
exit
caller.reject{ |x| x.include?('gem') }
options
up
build_translations
options
@label
options
caller.reject{ |x| x.include?('gem') }
options
@translations
up
@translations
options
@options
caller.reject{ |x| x.include?('gem') }
up
options
opts
@translations
build_translations
@translations
up
@translations
build_translations
opts
otions
options
up
opts
options
up
translate :before_start_instruction_text, "fuck u"
@translations
up
@translations
up
@translations
build_translations
down
next
up
@translations
up
@translations
@translations.keys
options
@translations
build_options
build_translations
optional_translations
options
@translations
build_translations
options
build_translations
build_options
object.translations
object.translations.keys
object.translations[:before_start_instruction_text]
object.translations[:before_start_instruction_text].to_s
key = :before_start_instruction_text
object.translations[key].to_s
TranslationBank.generic[key]
translation = object.translations[key]
translation.to_s == translation.fallback_translation
object.translations[:lol]
TranslationBank.generic[:lol]
"a" || "b"
nil || "b"
"a" || nil
element
element.class
exit
Decorators
Decorators::GenericTranslatableContentDecorator
exit
Decorators::GenericTranslatableContentHierarchyDecorator
exit
Decorators::GenericTranslatableContentHeirarchyDecorator
exit
object.translations
GenericTranslatableContentHeirarchyDecorator
exit
I18n.available_locales
exit
next
translatable_content
fallback
lol
next
translations_array
TranslationBank.generic[:lol]
exit
translations ||= nil && nil != "something"
translation ||= nil && nil != "something"
tranlsation
translation
translation ||= nil && nil != "something"
translation ||= "thing" && "thing" != "something"
translation
exit
DisplayContext::Null.instance
exit
DisplayContext::Null.instance
lang_code
exit
arr = ["", "", "test", "fuck u"]
"".length
"".size
arr.reject{ |e| e.length < 1 }
"".blank?
"".method(:blank?).source_location
CheckoutSystemModels::ProductConfigurations::MmrImpacktLiteConfiguration
class = 
class = _
CheckoutSystemModels::ProductConfigurations::MmrImpacktLiteConfiguration
class = _
mmilclsas = _
mmilclsas.method(:validates)
mmilclsas.method(:validates).source_location
CheckoutSystemModels::ProductConfigurations::MmrImpacktLiteConfiguration.last
mmrlite = _
mmrlite.pack_expectations
mmrlite.pack_expectations = ["this", "is", "a", "", ""
]
mmrlite.pack_expectations
mmrlite.save
mmrlite.pack_expectations
mmrlite.save!
exit!
arr
[""
]
[""] + arr
[""] + arr + [""]
subject.pack_expectations
subject.save!
pack_expectations
subject.create
subject.create!
subject.create!(product_configuration)
subject.save!
component = subject.add_survey_component({component_type: "default"})
component.save(:validate => false)
allow(component).to receive(:valid?){true}
component = subject.add_survey_component({component_type: "default"})
component.save(:validate => false)
allow(component).to receive(:valid?){true}
subject.save!
subject
exit!
exit
Product.last
Product.where(runs_on_legacy_survey_platform: true(]
Product.where(runs_on_legacy_survey_platform: true)
mmr = Product.find 8
mmr.runs_on_legacy_survey_platform = true
mmr.update!
mmr.save!
mmr
mmr.runs_on_legacy_survey_platform = false
mmr.save!
respondent_params
next
step
next
name
args
name
exit
params
respondent_params
user = AdminUser.create(email: 'denesh@zappistore.com', password: 'c0mpla!ning', password_confirmation: 'c0mpla!ning')
user.add_role :super_admin
user.save!
exit
{this: "is", a: "test"}
hash = _
ap hash
stringa = "{
  "product_category_id": 12,
"pack_diagnostics": [
"color",
"logo",
"shape"
],
"derived_expectations": [
"go well with cereal",
"nsio",
"yuipbno",
"bpuino",
"vytvybun",
"y8buin",
"yv8bu9in",
"8ybu9in0",
"fvygbuh",
"t7vyb8u9n",
"gy ",
"fvygby"
],
"pack_image_collection": [
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5fe7050e67f5401da2f001c4b1aa5b8eb1588ea7.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a28a88c42370eca0645e603ea536c4de1a6db7d6.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/906ad0e100bc0ca0e019ed2398215f282c1857b1.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9479bd1602b4ca17258a04d7b1ba9805a3157f02.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/139896132ea8f00f9baa86b059a5fd2ff9647acc.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/50b723989fbb16172021e63cb3c194467e01da48.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/4bb7b4bdcad7c1dc3d65089286154fc716dfd908.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/12ee34fd00d271872e0c9c1df95200d1dcc4174b.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/3f0fe72f829f6ed84dfca40a3a9703c883e2afcb.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c2093037fe74e7142e6b0396a72ad91612d96da9.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/8a4d52726686f69a4adb4b38ff67fc206d080cc7.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/841331f5f169506f3e949f1af04460a1ddef77cd.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/07e0144feb24c85ce2b0f06a403cae4e42c79a3a.jpg",
"https://s3.amazonaws.com/zappistore-dev/produ_collections/5b23c3139805ff41847600834950df57b58f5dbb.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a60b819debcc2c5965638151ea080897eaaaa683.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/34c6b322400de8a962b8ed1fcd6039a622e209c9.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/496686c9d7f8c5e629a6dc44488e439b065c01e8.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9dbbacb23e8d2f95f9adbb2a1e18fcbdbc282fa8.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/6d4be7f18bb8b62a8b34cd032c55bc1782aa8081.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/45bcb7b2254510f65d020b57c92a00eedcb87ba6.jpg",
"https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c1b886be2f6da9d6ec15066c0e87b3c3a664b553.jpg"
],
"pack_collection_type": "Rounded Bottles",
"device_quota": {
},
ening_quota": {
  }
}"
string = <<TEST
{
  "product_category_id": 12,
  "pack_diagnostics": [
    "color",
    "logo",
    "shape"
  ],
  "derived_expectations": [
    "go well with cereal",
    "nsio",
    "yuipbno",
    "bpuino",
    "vytvybun",
    "y8buin",
    "yv8bu9in",
    "8ybu9in0",
    "fvygbuh",
    "t7vyb8u9n",
    "gy ",
    "fvygby"
  ],
  "pack_image_collection": [
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5fe7050e67f5401da2f001c4b1aa5b8eb1588ea7.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a28a88c42370eca0645e603ea536c4de1a6db7d6.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/906ad0e100bc0ca0e019ed2398215f282c1857b1.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9479bd1602b4ca17258a04d7b1ba9805a3157f02.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/139896132ea8f00f9baa86b059a5fd2ff9647acc.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/50b723989fbb16172021e63cb3c194467e01da48.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/4bb7b4bdcad7c1dc3d65089286154fc716dfd908.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/12ee34fd00d271872e0c9c1df95200d1dcc4174b.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/3f0fe72f829f6ed84dfca40a3a9703c883e2afcb.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c2093037fe74e7142e6b0396a72ad91612d96da9.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/8a4d52726686f69a4adb4b38ff67fc206d080cc7.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/841331f5f169506f3e949f1af04460a1ddef77cd.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/07e0144feb24c85ce2b0f06a403cae4e42c79a3a.jpg",
    "https://s3.amazonaws.com/zappistore-dev/produpack_collections/5b23c3139805ff41847600834950df57b58f5dbb.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a60b819debcc2c5965638151ea080897eaaaa683.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/34c6b322400de8a962b8ed1fcd6039a622e209c9.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/496686c9d7f8c5e629a6dc44488e439b065c01e8.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9dbbacb23e8d2f95f9adbb2a1e18fcbdbc282fa8.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/6d4be7f18bb8b62a8b34cd032c55bc1782aa8081.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/45bcb7b2254510f65d020b57c92a00eedcb87ba6.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c1b886be2f6da9d6ec15066c0e87b3c3a664b553.jpg"
  ],
  "pack_collection_type": "Rounded Bottles",
  "device_quota": {
  screening_quota": {
  }
exit
stringa = <<-TEST
{
  "product_category_id": 12,
  "pack_diagnostics": [
    "color",
    "logo",
    "shape"
  ],
  "derived_expectations": [
    "go well with cereal",
    "nsio",
    "yuipbno",
    "bpuino",
    "vytvybun",
    "y8buin",
    "yv8bu9in",
    "8ybu9in0",
    "fvygbuh",
    "t7vyb8u9n",
    "gy ",
    "fvygby"
  ],
  "pack_image_collection": [
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5fe7050e67f5401da2f001c4b1aa5b8eb1588ea7.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a28a88c42370eca0645e603ea536c4de1a6db7d6.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/906ad0e100bc0ca0e019ed2398215f282c1857b1.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9479bd1602b4ca17258a04d7b1ba9805a3157f02.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/139896132ea8f00f9baa86b059a5fd2ff9647acc.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/50b723989fbb16172021e63cb3c194467e01da48.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/4bb7b4bdcad7c1dc3d65089286154fc716dfd908.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/12ee34fd00d271872e0c9c1df95200d1dcc4174b.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/3f0fe72f829f6ed84dfca40a3a9703c883e2afcb.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c2093037fe74e7142e6b0396a72ad91612d96da9.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/8a4d52726686f69a4adb4b38ff67fc206d080cc7.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/841331f5f169506f3e949f1af04460a1ddef77cd.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/07e0144feb24c85ce2b0f06a403cae4e42c79a3a.jpg",
    "https://s3.amazonaws.com/zappistore-dev/produ_collections/5b23c3139805ff41847600834950df57b58f5dbb.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a60b819debcc2c5965638151ea080897eaaaa683.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/34c6b322400de8a962b8ed1fcd6039a622e209c9.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/496686c9d7f8c5e629a6dc44488e439b065c01e8.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9dbbacb23e8d2f95f9adbb2a1e18fcbdbc282fa8.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/6d4be7f18bb8b62a8b34cd032c55bc1782aa8081.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/45bcb7b2254510f65d020b57c92a00eedcb87ba6.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c1b886be2f6da9d6ec15066c0e87b3c3a664b553.jpg"
  ],
  "pack_collection_type": "Rounded Bottles",
  "device_quota": {
  },
 ening_quota": {
  }
<<-HEREDOC
{
  "product_category_id": 12,
  "pack_diagnostics": [
    "color",
    "logo",
    "shape"
  ],
  "derived_expectations": [
    "go well with cereal",
    "nsio",
    "yuipbno",
    "bpuino",
    "vytvybun",
    "y8buin",
    "yv8bu9in",
    "8ybu9in0",
    "fvygbuh",
    "t7vyb8u9n",
    "gy ",
    "fvygby"
  ],
  "pack_image_collection": [
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5fe7050e67f5401da2f001c4b1aa5b8eb1588ea7.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a28a88c42370eca0645e603ea536c4de1a6db7d6.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/906ad0e100bc0ca0e019ed2398215f282c1857b1.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9479bd1602b4ca17258a04d7b1ba9805a3157f02.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/139896132ea8f00f9baa86b059a5fd2ff9647acc.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/50b723989fbb16172021e63cb3c194467e01da48.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/4bb7b4bdcad7c1dc3d65089286154fc716dfd908.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/12ee34fd00d271872e0c9c1df95200d1dcc4174b.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/3f0fe72f829f6ed84dfca40a3a9703c883e2afcb.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c2093037fe74e7142e6b0396a72ad91612d96da9.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/8a4d52726686f69a4adb4b38ff67fc206d080cc7.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/841331f5f169506f3e949f1af04460a1ddef77cd.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/07e0144feb24c85ce2b0f06a403cae4e42c79a3a.jpg",
    "https://s3.amazonaws.com/zappistore-dev/produollections/5b23c3139805ff41847600834950df57b58f5dbb.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a60b819debcc2c5965638151ea080897eaaaa683.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/34c6b322400de8a962b8ed1fcd6039a622e209c9.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/496686c9d7f8c5e629a6dc44488e439b065c01e8.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9dbbacb23e8d2f95f9adbb2a1e18fcbdbc282fa8.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/6d4be7f18bb8b62a8b34cd032c55bc1782aa8081.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/45bcb7b2254510f65d020b57c92a00eedcb87ba6.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c1b886be2f6da9d6ec15066c0e87b3c3a664b553.jpg"
  ],
  "pack_collection_type": "Rounded Bottles",
  "device_quota": {
  },
  "ing_quota": {
  }
exit
<<-TEST
{
  "product_category_id": 12,
  "pack_diagnostics": [
    "color",
    "logo",
    "shape"
  ],
  "derived_expectations": [
    "go well with cereal",
    "nsio",
    "yuipbno",
    "bpuino",
    "vytvybun",
    "y8buin",
    "yv8bu9in",
    "8ybu9in0",
    "fvygbuh",
    "t7vyb8u9n",
    "gy ",
    "fvygby"
  ],
  "pack_image_collection": [
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5fe7050e67f5401da2f001c4b1aa5b8eb1588ea7.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a28a88c42370eca0645e603ea536c4de1a6db7d6.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/906ad0e100bc0ca0e019ed2398215f282c1857b1.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9479bd1602b4ca17258a04d7b1ba9805a3157f02.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/139896132ea8f00f9baa86b059a5fd2ff9647acc.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/50b723989fbb16172021e63cb3c194467e01da48.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/4bb7b4bdcad7c1dc3d65089286154fc716dfd908.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/12ee34fd00d271872e0c9c1df95200d1dcc4174b.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/3f0fe72f829f6ed84dfca40a3a9703c883e2afcb.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c2093037fe74e7142e6b0396a72ad91612d96da9.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/8a4d52726686f69a4adb4b38ff67fc206d080cc7.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/841331f5f169506f3e949f1af04460a1ddef77cd.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/07e0144feb24c85ce2b0f06a403cae4e42c79a3a.jpg",
    "https://s3.amazonaws.com/zappistore-dev/produ_collections/5b23c3139805ff41847600834950df57b58f5dbb.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a60b819debcc2c5965638151ea080897eaaaa683.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/34c6b322400de8a962b8ed1fcd6039a622e209c9.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/496686c9d7f8c5e629a6dc44488e439b065c01e8.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9dbbacb23e8d2f95f9adbb2a1e18fcbdbc282fa8.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/6d4be7f18bb8b62a8b34cd032c55bc1782aa8081.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/45bcb7b2254510f65d020b57c92a00eedcb87ba6.jpg",
    "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c1b886be2f6da9d6ec15066c0e87b3c3a664b553.jpg"
  ],
  "pack_collection_type": "Rounded Bottles",
  "device_quota": {
  },
 ening_quota": {
  }
}TEST
TEST
exit
DatabaseModels::Survey.last
survey = _
exit
mmr
exit
mmr = DatabaseModels::Survey.last
mmr
exit
context.configuration
context.configuration[:survey_components]
context
next
validate_and_yield
next
blueprint_checking_result
exit
blueprint_checking_display_blueprint_mismatches_errors(blueprint_checking_result)
display_blueprint_mismatches_errors(blueprint_checking_result)
next
step
next
@resource.valid?
next
e
next
e
e.backtrace
context.configuration
context.configuration[:survey_component[
    context.configuration[:survey_component]
  ]
]
context.configuration[:survey_component]
context.configuration[:survey_component][self.pack_image_source]
self.pack_image_source
message
e.backtrace
e.inspect
e.backtrace
self.pack_image_source
context.configuration[:survey_component]
context.configuration[:survey_component].class
context.configuration[:survey_component].keys
context.configuration[:survey_component].key(self.pack_image_source)
context.configuration[:survey_component][self.pack_image_source]
self.pack_image_source
context.configuration[:survey_component][self.pack_image_source]
context.configuration[:survey_component].keys
context.configuration[:survey_component]
# is discarded by IO and a 400 is returned. This is a hack, hopefully we can remove this when IO clean up their bit.
caller.reject{ |x| x.include?('gem') }
context.class
up
context
up
context
up
context.configuration
context.configuration.keys
context.configuration[:survey_components]
context.configuration[:survey_component]
up
context.configuration[:survey_components]
context
context.configuration[:survey_components]
e.backtrace
context.configuration
context.configuration[self.source]
self.source
up
context
context.class
caller.reject{ |x| x.include?('gem') }
caller.reject{ |x| x.include?('gem') 
  i[
    up
    configuration
configuration
configuration.keys
configuration.entries
up
context
context.configuration
context.configuration.elements
exit
translated
translatable_content
translated
translatable_content
translatable_content.to_s
translatable_content
ap translatable_content
translatable_content.lang_code
translatable_content.send(:@lang_code)
translatable_content.to_s
key
finder.find(key, alias_key)
finder.find(key.to_sym, alias_key)
lang_code
up
context
context.class
up
context.class
up
survey
object
object.survey
object.class
object.class.options
object.options
context
context.class
context[:display]
context[:display].lang_code
context
next
DisplayContext.null
context ? context[:display] : DisplayContext.null
display_conte
display_context
TranslationBank
translatable_content
object.translations
object.translations.generic[key]
object.translations
object.translations[key]
TanslationBank.generic[key]
TranslationBank.generic[key]
generic_translation
context.class
context
exit
next
translatable_content
next
fallback
next
translatable_content
34
translatable_content
object.translations[key]
caller.reject{ |x| x.include?('gem') 
self
context
context[:lol]
context.class
context
exit
DatabaseModels::Survey.find(9925)
mmr = _
{ "product_category_id": 12, "pack_diagnostics": [ "color", "logo", "shape" ], "derived_expectations": [ "go well with cereal", "nsio", "yuipbno", "bpuino", "vytvybun", "y8buin", "yv8bu9in", "8ybu9in0", "fvygbuh", "t7vyb8u9n", "gy ", "fvygby" ], "pack_image_collection": [ "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5fe7050e67f5401da2f001c4b1aa5b8eb1588ea7.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a28a88c42370eca0645e603ea536c4de1a6db7d6.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/906ad0e100bc0ca0e019ed2398215f282c1857b1.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9479bd1602b4ca17258a04d7b1ba9805a3157f02.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/139896132ea8f00f9baa86b059a5fd2ff9647acc.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/50b723989fbb16172021e63cb3c194467e01da48.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/4bb7b4bdcad7c1dc3d65089286154fc716dfd908.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/12ee34fd00d271872e0c9c1df95200d1dcc4174b.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/3f0fe72f829f6ed84dfca40a3a9703c883e2afcb.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c2093037fe74e7142e6b0396a72ad91612d96da9.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/8a4d52726686f69a4adb4b38ff67fc206d080cc7.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/841331f5f169506f3e949f1af04460a1ddef77cd.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/07e0144feb24c85ce2b0f06a403cae4e42c79a3a.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5b23c3139805ff41847600834950df57b58f5dbb.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a60b819debcc2c5965638151ea080897eaaaa683.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/34c6b322400de8a962b8ed1fcd6039a622e209c9.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/496686c9d7f8c5e629a6dc44488e439b065c01e8.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9dbbacb23e8d2f95f9adbb2a1e18fcbdbc282fa8.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/6d4be7f18bb8b62a8b34cd032c55bc1782aa8081.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/45bcb7b2254510f65d020b57c92a00eedcb87ba6.jpg", "https://s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c1b886be2f6da9d6ec15066c0e87b3c3a664b553.jpg" ], "pack_collection_type": "Rounded Bottles", "device_quota": { }, "screening_quota": { } }
{ "product_category_id" => 12, "pack_diagnostics" => [ "color", "logo", "shape" ], "derived_expectations" => [ "go well with cereal", "nsio", "yuipbno", "bpuino", "vytvybun", "y8buin", "yv8bu9in", "8ybu9in0", "fvygbuh", "t7vyb8u9n", "gy ", "fvygby" ], "pack_image_collection" => [ "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5fe7050e67f5401da2f001c4b1aa5b8eb1588ea7.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a28a88c42370eca0645e603ea536c4de1a6db7d6.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/906ad0e100bc0ca0e019ed2398215f282c1857b1.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9479bd1602b4ca17258a04d7b1ba9805a3157f02.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/139896132ea8f00f9baa86b059a5fd2ff9647acc.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/50b723989fbb16172021e63cb3c194467e01da48.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/4bb7b4bdcad7c1dc3d65089286154fc716dfd908.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/12ee34fd00d271872e0c9c1df95200d1dcc4174b.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/3f0fe72f829f6ed84dfca40a3a9703c883e2afcb.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c2093037fe74e7142e6b0396a72ad91612d96da9.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/8a4d52726686f69a4adb4b38ff67fc206d080cc7.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/841331f5f169506f3e949f1af04460a1ddef77cd.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/07e0144feb24c85ce2b0f06a403cae4e42c79a3a.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/5b23c3139805ff41847600834950df57b58f5dbb.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/a60b819debcc2c5965638151ea080897eaaaa683.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/34c6b322400de8a962b8ed1fcd6039a622e209c9.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/496686c9d7f8c5e629a6dc44488e439b065c01e8.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/9dbbacb23e8d2f95f9adbb2a1e18fcbdbc282fa8.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/6d4be7f18bb8b62a8b34cd032c55bc1782aa8081.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/45bcb7b2254510f65d020b57c92a00eedcb87ba6.jpg", "https =>//s3.amazonaws.com/zappistore-dev/production/system/pack_collections/c1b886be2f6da9d6ec15066c0e87b3c3a664b553.jpg" ], "pack_collection_type" => "Rounded Bottles", "device_quota" => { }, "screening_quota" => { } }
hash = _
mmr.config = hash
mmr.configuration_data = hash
mmr.save!
{ "zappistore_id" => "3f66067a-a241-4238-926a-ee37513bbe15", "presentation_type" => "mmr_product", "devices" => [ "desktop", "mobile" ], "advanced_analysis_brands" => [ ], "benchmark" => 0, "brand_attributes" => [ ], "brand_messages" => [ ], "brand_name" => "Generic Dairy", "concepts" => [ ], "image_urls" => [ ], "market_factors" => [ ], "media_url" => "https =>//s3.amazonaws.com/zappistore-dev/sandbox/media_files/303265f9b1693bc0c2e8ff5a8d631aa2001c5e09.jpg", "packs" => [ ], "pack_range_image" => "https =>//s3.amazonaws.com/zappistore-dev/sandbox/media_files/1a7b92485b7a3143fdf10d7672c69dfebfe762ed.jpg", "pack_title" => "Generic Milk 1", "product_name" => "Generic Milk", "product_type" => "milk", "stimuli" => [ ], "test_brand" => { }, "thumbnail_url" => "https =>//s3.amazonaws.com/zappistore-dev/sandbox/thumbnails/200x200/303265f9b1693bc0c2e8ff5a8d631aa2001c5e09.jpg", "total_brands" => [ ], "video_urls" => [ ] }
survey_comp_data = _
mmr.survey_component_data = survey_comp_data
mmr.save!
hash
mmr
mmr.blueprint_id = 126
mmr.save!
:mmr_impackt_lite_pages_flash_image_intro_before_start_instruction_text.humanize
"mmr_impackt_lite_pages_flash_image_intro_before_start_instruction_text".humanize
translation_metadata\
rstee
rstcer
xt
ei!rest
Connectors::InsightOut::Requests::SurveyVariables
Connectors::InsightOut::Requests::SurveyVariables.new
req = _
req.response
hij so %
exit
survey_repo = Repositories::SurveyRepository.new
survey_repo = survey.find 9925
survey = survey_repo.find 9925
survey
Connectors::InsightOut::Requests::SurveyVariables.new survey
Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
req.response
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
path
root_url
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
root_url
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
root_url
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
root_url
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9925
request = Connectors::InsightOut::Requests::SurveyVariables.new({ survey: survey })
request.response
config
config.host
config
self.method(:config)
self.method(:config).source_location
AppConfig
exit
class A
  def self.call
    puts "hi from A"
  end
end
exit
module A
  def self.call
    puts "hi from A"
  end
end
class B
  extends A
  def self.call
    super
    puts "hi from B"
  end
end
class B
  extend A
  def self.call
    puts "hi from B"
  end
end
B.call
class B
  extend A
  def self.call
    super
    puts "hi from B"
  end
end
B.call
exit
Jobs::JobLogger
exit
Jobs::JobLogger.log do |logger|
  logger.write("hi")
  1 + 1
end
exit
Jobs::JobLogger.log do |logger|
  logger.write("hi")
  1 + 1
end
item = _
item.class
exit
Jobs::JobLogger.log do |logger|
  logger.write("hi")
  1 + 1
end
exit
Jobs::JobLogger.log do |logger|
  logger.write("hi")
  1 + 1
end
w
exit
Jobs.CheckSurveyClosedStatus.perform
Jobs.CheckSurveyClosedStatus
Jobs::CheckSurveyClosedStatus
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
ext
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
next
exit
Jobs::CheckSurveyClosedStatus.perform
child_class
exit
child_class
exit
Jobs::CheckSurveyClosedStatus.perform
child_class.prepend Jobs::JobLoggine
child_class.prepend Jobs::JobLogging
Jobs::JobLogging
exit
Jobs::JobLogging
exit
Jobs::JobLogging
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
Jobs::CheckSurveyClosedStatus.perform
exit
DatabaseModels::Survey.all
exit
Jobs::CheckSurveyClosedStatus.to_s
exit
surveys.first.class
exit
surveys
exit
db_surveys
surveys
surveys.each{ |survey| survey.save! }
db_surveys
DatabaseModels::Survey.all
3.times.map{ create(:survey).tap.save! }
3.times.map{ create(:survey).tap{ |s| s.save! } }
exit
db_surveys
db_surveys.relad
db_surveys.reload
surveys
DatabaseModels::Survey.all
exit
db_surveys
DatabaseModels::Survey.all
surveys
DatabaseModels::Survey.all
exit
survey
exit
DatabaseModels::Survey.last
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_repo.surveys_to_sync_with_io
database_objects.where("finished_at is null and created_at >= ?", 1.month.ago)
database_objects.where("finished_at not null and insight_out_complete_verified_at is null and created_at >= ?", 1.month.ago)
database_objects.where("finished_at is not null and insight_out_complete_verified_at is null and created_at >= ?", 1.month.ago)
DatbaseModels::Survey.last
DatabaseModels::Survey.last
DatabaseModels::Survey.last.report_id
DatabaseModels::Survey.last
DatabaseModels::Survey.last.external_report_id
exit
DatabaseModels::Survey.last.external_report_id
survesurvey_repo = Repositories::SurveyRepository.new
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9921
Connectors::InsightOut::Requests::SurveyVariables.new({survey: survey})
request = _
request.response
response = _
PP.pp _
survey
survey.external_report_id = 2761
survey_repo.update(survey)
Connectors::InsightOut::Requests::SurveyVariables.new({survey: survey})
request = _
request.response
response_data = _
response_data[:code]
response_data.options
response_data.options[:response_code]
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9921
survey.external_report_id
request = Connectors::InsightOut::Requests::SurveyVariables.new({survey: survey})
response_data = request.response
response_data.options
response_data = request.response
exit
survey_repo = Repositories::SurveyRepository.new
survey = survey_repo.find 9921
request = Connectors::InsightOut::Requests::SurveyVariables.new({survey: survey})
response_data = request.response
config.user
config.access_key
response_data
response_data[:code]
response_data.options
survey.external_report_id = 11438
survey_repo.update surfvey
survey_repo.update survey
request = Connectors::InsightOut::Requests::SurveyVariables.new({survey: survey})
response_data = request.response
response_data.op
response_data.options
survey.external_report_id = 2690
survey_repo.update survey
request = Connectors::InsightOut::Requests::SurveyVariables.new({survey: survey})
response_data
response_data = 
request.response
code
response_data
exi
exit
next
exit
to_check
next
exit
country
surveys
exut
exit
surveys
surveys.first
create(:survey, finished_at: Time.now, created_at: 2.days.ago, target: { country_code: country.code })
exit
survey.target
survey.target.attributes
survey.target
survey
survey.id
survey.target
survey.class
caller.reject{ |x| x.include?('gem') 
  caller.reject{ |x| x.include?('gem') 
  }
}
caller.reject{ |x| x.include?('gem') }
vs
survey.class
surve
survey.class
survey
response
exit
next
survey.insight_out_complete_verified_at
survey
next
survey.id
record
record.reload
unmap_record(record.reload, survey)
survey_repo.find(1)
DatabaseModels::Survey.all
DatabaseModels::Survey.map(&:insight_out_complete_verified_at)
DatabaseModels::Survey.all.map(&:insight_out_complete_verified_at)
closed_survey.insight_out_complete_verified_at
open_survey.insight_out_complete_verified_at
surveys
exit
survey_repo.find 1
db_surveys
jjjjjjjtest spec/lib/jobs/check_survey_closed_status_spec.rb:138j
exit
survey
survey.class
to_check
to_check.count
to_check.first.class
exit
throws_exceptoin.count
throws_exceptoin[0]
throws_exceptoin
exit
thor
throws_exceptoin.count
exit
survey
survey.external_report_id
processable_open
exit
response
response_data.options
response_data.options[:response_body]
JSON.parse _
response_data.json
response_data.json.symbolize_keys
exit
Product.none
Product.method(:none).source_location
Product.public_methods(false)
Product.public_methods(false).count
Product.public_methods.count
exit
DatabaseModels::Survey.last
DatabaseModels::SurveyResponse.last
exit
labels
labels.class
:questions
label
Generators::Translations.new(
  labels << :questions << label,
  required_translations,
  optional_translations
)
self.method(:label).source_location
caller.reject{ |x| x.include?('gem') }
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_repo.find 9924
suvey = _
survey = _
generator = Services::DummyResponsesGenerator.new(survey)
opts = { size: 11 }
survey = Repositories::SurveyRepository.new.find 8726
survey_response_repo = Repositories::SurveyResponseRepository.new
generator = Services::DummyResponsesGenerator.new survey
genders = { 1 => 5, 2 => 6 }
age_ranges = {(18..34) => 0, (35..44) => 0, (45..54) => 11 }
suppliers = { "Fulcrum" => 0, "5548" => 11, "5529" => 0, "5347" => 0 }
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
responses = generator.call(opts)
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey_response_repo.bulk_insert(responses)
survey.id
survey = survey_repo.find 9924
generator = Services::DummyResponsesGenerator.new survey
responses = generator.call(opts)
survey = survey_repo.find 9923
generator = Services::DummyResponsesGenerator.new survey
responses = generator.call(opts)
survey = survey_repo.find 9923
survey_repo = Repositories::SurveyRepository.new
survey_response_repo = Repositories::SurveyResponseRepository.new
survey = survey_repo.find 9923
generator = Services::DummyResponsesGenerator.new survey
responses = generator.call(opts)
opts = { gender: genders, age: age_ranges, supplier_code: suppliers, size: 11 }
opts = { size: 11 }
responses = generator.call(opts)
survey_response_repo.bulk_insert(responses)
exit
Builders::Question
Builders::Question.build
Measures::UnileverConsumerClassification.last
Measures::UnileverConsumerClassification
Repositories::Measure.all
Repositories::Measure.new.all
Repositories::Measure.new.last
Repositories::Measure.new.all.last
measure = _
exit!
options
optiosn
options
label
Product.last
buzz = _
caller.reject{ |x| x.include?('gem') }
up
@options
up
builder.class
exit
options
up
caller.reject{ |x| x.include?('gem') }
label
down
lable
label
exit
options
page_routing.next_visible_page
exit
survey_response.survey_id
current_page
survey.questionnaire
survey
survey.questionnaire.pages
survey_response
survey_response.current_page_id
survey.questionnaire.find_page_by_id(1)
survey.questionnaire.find_page_by_id(2)
survey.questionnaire.pages
survey.questionnaire.pages.first.id
survey.questionnaire.pages[1].id
exit
survey
survey.lang_code
survey_response
survey_response.lang_code
SurveyResponseLanguage.new(survey, survey_response).execute
survey.configuration
survey.configuration[:language_code]
exit
SurveyResponseLanguage.new(survey, survey_response).execute
survey.configuration
survey.configuration[:lang_code]
survey.configuration[:lang_code] = :GB_en
survey.configuration[:lang_code] = nil
survey.configuration[:lang_code]
survey.configuration[:language_code]
exit
SurveyResponseLanguage.new(survey, survey_response).execute
exit
result.redirect_url
exit
result.redirect_url
result
exit
page_routing
controller
controller.page_routign
controller.page_routing
controller.send(:page_routing)
controller.send(:page_routing).pages
controller.send(:page_routing).page
controller.send(:page_routing).current_page
controller.send(:page_routing)
controller.send(:page_routing).last_page
survey.questionnaire.pages
survey.questionnaire.pages.last
survey.questionnaire.pages.last.class
controller.send(:page_routing).current_page.class
survey_response.current_page_id
survey.questionnaire.pages.last.id
exit
result = get :next
result.request.session
result.request.session["current_survey_response_id"]
result.request.session[:current_survey_response_id]
result.request.session
result.request.session[:current_survey_response_id]
result.request.session["current_survey_response_id"]
DatabaseModels::Survey.all
exit
result.redirect_url
exit
survey
survey.configuration[:language_code]
survey.configuration[:fieldwork_dates]
survey_repository.create(survey)
survey.configuration[:fieldwork_dates]
survey.find(survey.id)
survey.find(1)
survey_repository.find(1)
s = _
s
survey
survey.class
survey.configuration
survey.configuration[:language_code]
!page_routing.visible?(page_routing.current_page)
result.redirect_url
survey.closed?
page_routing.visible?(page_routing.current_page)
result.redirect_url
exit
survey_repsonse_repo = Repositories::SurveyResponseRepository.new
dbsr = DatabaseModels::SurveyResponse.last
survey_repsonse_repo.find dbsr.id
record
exit
caller.reject{ |x| x.include?('gem') }
exit
quota_keys
exit
survey.id
survey_response.id
survey_response_reloaded
survey_response
survey_response_repo.create(survey_response)
survey_response
database_model_class.new(attrs)
record = _
record.save!
record
unmap_record(record, survey_response)
up
page_routing
up
page_routing
survey_response_repo.create(survey_response)
survey_response.class
survey_response_repo.create(survey_response)
survey_response.class
survey_response_reloaded
survey_response
survey_response_repo.create(survey_response)
survey_response
survey_response_repo.create(survey_response)
survey_response = _
survey_response_reloaded
survey_response
survey_response_reloaded
survey_response.class
survey_response.id
survey_response
SurveyResponse.new(survey_id: 24)
exit
survey_response.id
survey_response.reload
record.is_from_sampling_engine
object
object.class
next
object
object.class
record
survey_response
survey_response.class
up
object
up
survey_response
down
record
next
unmap_record(record, survey_response)
unmap_record(record, survey_response).class
exit
recorod
record
survey_response_repo.create(survey_response)
survey_response
survey_response = survey_response_repo.create(survey_response)
survey_response_2 = survey_response_repo.create(survey_response)
survey_response = survey_response_2
survey_response_2 = survey_response_repo.create(survey_response)
survey_response = survey_response_2
next
object.class
object.id
object
survey_response
survey_response.class
exit
survey_response.class
survey_response.id
survey_response.class
survey_response_repo.create(survey_response).class
record
record.public_send(survey_method)
survey_method
record.class
record.class.next_survey_response_index
survey_method
self.method(:survey_method)
self.method(:survey_method).source_location
record.class
record.survey
record
record.survey
survey.survey_responses
survey
result
exit
DatabaseModels::PanelProvider.all
DatabaseModels::PanelProvider.first.regions
DatabaseModels::PanelProvider.first.genders
DatabaseModels::PanelProvider.all
exit
survey_repo = Repositories::SurveyRepository.new
survey_repo.find(DatabaseModels::Survey.last.id)
survey = _
survey.panel_supplier_id
exit
survey_repo = Repositories::SurveyRepository.new
survey_repo.find(9923)
survey = _
survey.panel_supplier_id
survey.panel_supplier_id = 4
survey_repo.update(survey)
survey
survey.reload
survey_repo.update(survey)
DatabaseModels::Survey.find survey.id
exit
nil.try(:lol)
exit
